{-
Quick tips:
- Use Haskell syntax highlighting
- Use block comments (the one starting with braces) for Elsa comments
- Use single line comments (the one starting with --) for Swift documentation

CPython bytecode is defined in: Lib -> opcode.py.
Docs from: https://docs.python.org/3.7/library/dis.html
-}

{- TODO: Real types -}
@struct Count = ()
@struct Counts = ()
@struct VarNum = ()
@struct I = ()
@struct Delta = ()
@struct Flags = ()
@struct Target = ()
@struct BigInt = ()

@enum Constant =
  Integer(BigInt)
  | Float(Double)
  | Complex(Double real, Double imag)
  | Boolean(Bool)
  | String(String)
  | Bytes(Data)
  {- TODO: | Code(code: Box<CodeObject>) -}
  | Tuple(Constant*)
  | None
  | Ellipsis

@enum ComparisonOperator =
  -- True when two operands are equal.
  Equal
  -- True when two operands are not equal.
  | NotEqual
  -- True when left operand is less than the value of right operand.
  | Less
  -- True when left operand is less than or equal to the value of right operand.
  | LessEqual
  -- True when left operand is greater than the value of right operand.
  | Greater
  -- True when left operand is greater than or equal to the value of right operand.
  | GreaterEqual
  -- True when x and y are the same object.
  | Is
  -- Negation of `x is y`.
  | IsNot
  -- True when x is a member of s.
  | In
  -- Negation of `x in s`
  | NotIn
  {- TODO: those -}
  {- | ExceptionMatch -}
  {- | Bad -}

@enum Bytecode =

{- ------- -}
{- General -}
{- ------- -}

  -- Do nothing code.
  Nop
  -- Removes the top-of-stack (TOS) item.
  | PopTop
  -- Swaps the two top-most stack items.
  | RotTwo
  -- Lifts second and third stack item one position up,
  -- moves top down to position three.
  | RotThree
  -- Duplicates the reference on top of the stack.
  | DupTop
  -- Duplicates the two references on top of the stack,
  -- leaving them in the same order.
  | DupTopTwo

{- ---------------- -}
{- Unary operations -}
{- ---------------- -}

  {-
    1. take the top of the stack
    2. apply the operation
    3. push the result back on the stack
  -}

  -- Implements `TOS = +TOS`.
  | UnaryPositive
  -- Implements `TOS = -TOS`.
  | UnaryNegative
  -- Implements `TOS = not TOS`.
  | UnaryNot
  -- Implements `TOS = ~TOS`.
  | UnaryInvert

{- ----------------- -}
{- Binary operations -}
{- ----------------- -}

  {-
    1. remove the top of the stack (TOS)
    2. remove the second top-most stack item (TOS1) from the stack
    3. perform the operation
    4. put the result back on the stack
  -}

  -- Implements `TOS = TOS1 ** TOS`.
  | BinaryPower
  -- Implements `TOS = TOS1 * TOS`.
  | BinaryMultiply
  -- Implements `TOS = TOS1 @ TOS`.
  | BinaryMatrixMultiply
  -- Implements `TOS = TOS1 // TOS`.
  | BinaryfloorDivide
  -- Implements `TOS = TOS1 / TOS`.
  | BinaryTrueDivide
  -- Implements `TOS = TOS1 % TOS`.
  | BinaryModulo
  -- Implements `TOS = TOS1 + TOS`.
  | BinaryAdd
  -- Implements `TOS = TOS1 - TOS`.
  | BinarySubtract
  -- Implements `TOS = TOS1[TOS]`.
  | BinarySubscr
  -- Implements `TOS = TOS1 << TOS`.
  | BinaryLShift
  -- Implements `TOS = TOS1 >> TOS`.
  | BinaryRShift
  -- Implements `TOS = TOS1 & TOS`.
  | BinaryAnd
  -- Implements `TOS = TOS1 ^ TOS`.
  | BinaryXor
  -- Implements `TOS = TOS1 | TOS`.
  | BinaryOr

{- ----------- -}
{-  Comparison -}
{- ----------- -}

  -- Performs a `Boolean` operation.
  | CompareOp(ComparisonOperator)

{- ------------------ -}
{-  Coroutine opcodes -}
{- ------------------ -}

  -- Implements `TOS = GetAwaitable(TOS)`.
  --
  -- `GetAwaitable(o)` returns:
  -- - `o` if `o` is a coroutine object
  -- - generator object with the `CoIterableCoroutine` flag
  -- - `o.Await`
  | GetAwaitable
  -- Implements `TOS = TOS.AIter()`.
  | GetAIter
  -- Implements `Push(GetAwaitable(TOS.ANext()))`.
  -- See `GetAwaitable` for details.
  | GetANext
  {- TODO: Changed in version 3.7: Returning awaitable objects from AIter is no longer supported. -}

{- ---------- -}
{- Generators -}
{- ---------- -}

  -- Pops TOS and yields it from a generator.
  | YieldValue
  -- Pops TOS and delegates to it as a subiterator from a generator.
  | YieldFrom

{- ----- -}
{- Print -}
{- ----- -}

  -- Implements the expression statement for the interactive mode.
  -- TOS is removed from the stack and printed.
  -- In non-interactive mode, an expression statement is terminated with PopTop.
  | PrintExpr

{- ------------------- -}
{- Loops and iterators -}
{- ------------------- -}

  -- Pushes a block for a loop onto the block stack.
  -- The block spans from the current instruction with a size of delta bytes.
  | SetupLoop(delta)

  -- TOS is an iterator. Call its `Next()` method.
  -- If this `yields` a new value, push it on the stack (leaving the iterator below it).
  -- If not then TOS is popped, and the byte code counter is incremented by delta.
  | ForIter(delta)

  -- Implements `TOS = iter(TOS)`.
  | GetIter
    -- If TOS is a generator iterator or coroutine object then it is left as is.
  -- Otherwise, implements `TOS = iter(TOS)`.
  | GetYieldFromIter

  -- Terminates a loop due to a break statement.
  | BreakLoop
  -- Continues a loop due to a continue statement.
  -- `target` is the address to jump to (which should be a `ForIter` instruction).
  | ContinueLoop(target)

{- ------------ -}
{-  Collections -}
{- ------------ -}

  -- Creates a tuple consuming `count` items from the stack,
  -- and pushes the resulting tuple onto the stack.
  | BuildTuple(count)
  -- Creates a list consuming `count` items from the stack,
  -- and pushes the resulting list onto the stack.
  | BuildList(count)
  -- Creates a set consuming `count` items from the stack,
  -- and pushes the resulting set onto the stack.
  | BuildSet(count)
  -- Pushes a new dictionary object onto the stack.
  -- Pops 2 * count items so that the dictionary holds count entries:
  -- {..., TOS3: TOS2, TOS1: TOS}.
  | BuildMap(count)
  -- The version of `BuildMap` specialized for constant keys.
  -- `count` values are consumed from the stack.
  -- The top element on the stack contains a tuple of keys.
  | BuildConstKeyMap(count)

  -- Calls `set.add(TOS1[-i], TOS)`. Container object remains on the stack.
  -- Used to implement set comprehensions.
  | SetAdd(i)
  -- Calls `list.append(TOS[-i], TOS)`. Container object remains on the stack.
  -- Used to implement list comprehensions.
  | ListAppend(i)
  -- Calls `dict.setitem(TOS1[-i], TOS, TOS1)`. Container object remains on the stack.
  -- Used to implement dict comprehensions.
  | MapAdd(i)

{- -------- -}
{-  Unpack  -}
{- -------- -}

  -- Pops count iterables from the stack, joins them in a single tuple,
  -- and pushes the result.
  -- Implements iterable unpacking in tuple displays `(*x, *y, *z)`.
  | BuildTupleUnpack(count)
  -- This is similar to `BuildTupleUnpack`, but is used for `f(*x, *y, *z)` call syntax.
  -- The stack item at position count + 1 should be the corresponding callable `f`.
  | BuildTupleUnpackWithCall(count)

  -- This is similar to `BuildTupleUnpack`, but pushes a list instead of tuple.
  -- Implements iterable unpacking in list displays `[*x, *y, *z]`.
  | BuildListUnpack(count)

  -- This is similar to `BuildTupleUnpack`, but pushes a set instead of tuple.
  -- Implements iterable unpacking in set displays `{*x, *y, *z}`.
  | BuildSetUnpack(count)

  -- Pops count mappings from the stack, merges them into a single dictionary,
  -- and pushes the result.
  -- Implements dictionary unpacking in dictionary displays `{**x, **y, **z}`.
  | BuildMapUnpack(count)
  -- This is similar to `BuildMapUnpack`, but is used for `f(**x, **y, **z)` call syntax.
  -- The stack item at position count + 2 should be the corresponding callable `f`.
  | BuildMapUnpackWithCall(count)

  -- Unpacks TOS into count individual values,
  -- which are put onto the stack right-to-left.
  | UnpackSequence(count)

  -- Implements assignment with a starred target:
  --
  -- Unpacks an iterable in TOS into individual values, where the total number
  -- of values can be smaller than the number of items in the iterable:
  -- one of the new values will be a list of all leftover items.
  --
  -- The low byte of counts is the number of values before the list value,
  -- the high byte of counts the number of values after it.
  -- The resulting values are put onto the stack right-to-left.
  | UnpackEx(counts)

{- --------------------- -}
{-  Store, load, delete  -}
{- --------------------- -}

  -- Pushes constant onto the stack.
  | LoadConst(Constant)

  -- Implements `name = TOS`.
  | StoreName(String)
  -- Pushes the value associated with `name` onto the stack.
  | LoadName(String)
  -- Implements `del name`.
  | DeleteName(String)

  -- Implements `TOS.name = TOS1`.
  | StoreAttr(String)
  -- Replaces TOS with `getAttr(TOS, name)`.
  | LoadAttr(String)
  -- Implements `del TOS.name`.
  | DeleteAttr(String)

  -- Works as StoreName, but stores the name as a global.
  | StoreGlobal(String)
  -- Loads the global named `name` onto the stack.
  | LoadGlobal(String)
  -- Works as DeleteName, but deletes a global name.
  | DeleteGlobal(String)

  {- TODO: Pushes a reference to the local CoVarnames[VarNum] onto the stack. -}
  | LoadFast(VarNum)
  {- TODO: Stores TOS into the local CoVarnames[VarNum]. -}
  | StoreFast(VarNum)
  {- TODO: Deletes local CoVarnames[VarNum]. -}
  | DeleteFast(VarNum)

  -- Loads the cell contained in slot i of the cell and free variable storage.
  -- Pushes a reference to the object the cell contains on the stack.
  | LoadDeref(i)
  -- Stores TOS into the cell contained in slot i of the cell and free variable storage.
  | StoreDeref(i)
  -- Empties the cell contained in slot i of the cell and free variable storage.
  -- Used by the del statement.
  | DeleteDeref(i)

  -- Much like `LoadDeref` but first checks the locals dictionary before consulting the cell.
  -- This is used for loading free variables in class bodies.
  | LoadClassderef(i)

{- ---------- -}
{-  Function  -}
{- ---------- -}

{- TODO: docs -}
  -- Pushes a new function object on the stack.
  --
  -- From bottom to top, the consumed stack must consist of values if the argument carries a specified flag value
  -- - `0x01` - a tuple of default values for positional-only and positional-or-keyword parameters in positional order
  -- - `0x02` - a dictionary of keyword-only parameters’ default values
  -- - `0x04` - an annotation dictionary
  -- - `0x08` - a tuple containing cells for free variables, making a closure
  -- the code associated with the function (at TOS1)
  -- the qualified name of the function (at TOS)
  | MakeFunction(UInt argc)

  -- Calls a callable object with positional arguments.
  -- `argc` indicates the number of positional arguments.
  --
  -- Stack layout (1st item means TOS):
  -- - positional arguments, with the right-most argument on top
  -- - callable object to call.
  --
  -- It will:
  -- 1. pop all arguments and the callable object off the stack
  -- 2. call the callable object with those arguments
  -- 3. push the return value returned by the callable object
  {- TODO: This opcode is used only for calls with positional arguments. -}
  | CallFunction(UInt argc)

  -- Calls a callable object with positional (if any) and keyword arguments.
  -- `argc` indicates the total number of positional and keyword arguments.
  --
  -- Stack layout (1st item means TOS):
  -- - tuple of keyword argument names
  -- - keyword arguments in the order corresponding to the tuple
  -- - positional arguments, with the right-most parameter on top
  -- - callable object to call.
  --
  -- It will:
  -- 1. pop all arguments and the callable object off the stack
  -- 2. call the callable object with those arguments
  -- 3. push the return value returned by the callable object.
  {- TODO: Changed in version 3.6: Keyword arguments are packed in a tuple instead of a dictionary, argc indicates the total number of arguments. -}
  | CallFunctionKw(UInt argc)

  -- Calls a callable object with variable set of positional and keyword arguments.
  --
  -- Stack layout (1st item means TOS):
  -- - (if `hasKeywordArguments` is set) mapping object containing keyword arguments
  -- - iterable object containing positional arguments and a callable object to call
  --
  -- `BuildmapUnpackWithCall` and `BuildTupleUnpackWithCall` can be used for
  -- merging multiple mapping objects and iterables containing arguments.
  --
  -- It will:
  -- 1. pop all arguments and the callable object off the stack
  -- 2. mapping object and iterable object are each “unpacked” and their
  -- contents is passed in as keyword and positional arguments respectively
  -- 3. call the callable object with those arguments
  -- 4. push the return value returned by the callable object
  | CallFunctionEx(Bool hasKeywordArguments)

  -- Returns with TOS to the caller of the function.
  | ReturnValue

{- ----- -}
{- Class -}
{- ----- -}

  {- TODO: doc -}

  -- Pushes `builtins.BuildClass()` onto the stack.
  -- It is later called by `CallFunction` to construct a class.
  | LoadBuildClass

  -- Loads a method named `name` from TOS object.
  --
  -- TOS is popped and method and TOS are pushed when interpreter can call unbound method directly.
  -- TOS will be used as the first argument (self) by `CallMethod`.
  -- Otherwise, NULL and method is pushed (method is bound method or something else).
  | LoadMethod(String)

  -- Calls a method.
  -- `argc` is number of positional arguments.
  -- Keyword arguments are not supported.
  --
  -- This opcode is designed to be used with `LoadMethod`.
  -- Positional arguments are on top of the stack.
  -- Below them, two items described in `LoadMethod` on the stack.
  -- All of them are popped and return value is pushed.
  | CallMethod(UInt argc)

{- -------- -}
{-  Import  -}
{- -------- -}

  -- Loads all symbols not starting with '_' directly from the module TOS
  -- to the local namespace.
  --
  -- The module is popped after loading all names.
  -- This opcode implements `from module import *`.
  | ImportStar

  -- Imports the module `name`.
  --
  -- TOS and TOS1 are popped and provide the `fromlist` and `level` arguments of `Import()`.
  -- The module object is pushed onto the stack.
  -- The current namespace is not affected: for a proper import statement,
  -- a subsequent StoreFast instruction modifies the namespace.
  | ImportName(String)

  -- Loads the attribute `name` from the module found in TOS.
  --
  -- The resulting object is pushed onto the stack,
  -- to be subsequently stored by a `StoreFast` instruction.
  | ImportFrom(String)

{- --------- -}
{- Try/catch -}
{- --------- -}

  -- Removes one block from the block stack.
  -- The popped block must be an exception handler block,
  -- as implicitly created when entering an except handler.
  -- In addition to popping extraneous values from the frame stack,
  -- the last three popped values are used to restore the exception state.
  | PopExcept

  -- Terminates a finally clause.
  -- The interpreter recalls whether the exception has to be re-raised,
  -- or whether the function returns, and continues with the outer-next block.
  | EndFinally

  -- Pushes a try block from a try-except clause onto the block stack.
  -- `delta` points to the first except block.
  | SetupExcept(delta)

  -- Pushes a try block from a try-except clause onto the block stack.
  -- `delta` points to the finally block.
  | SetupFinally(delta)

  -- Raises an exception using one of the 3 forms of the raise statement,
  -- depending on the value of argc:
  -- - 0: raise (re-raise previous exception)
  -- - 1: raise TOS (raise exception instance or type at TOS)
  -- - 2: raise TOS1 from TOS (raise exception instance or type at TOS1 with Cause set to TOS)
  | RaiseVarargs(UInt argc)

{- ---- -}
{- With -}
{- ---- -}

  -- This opcode performs several operations before a `with` block starts.
  --
  -- It does following operations:
  -- 1.loads `Exit()` from the context manager and pushes it onto the stack for later use by `WithCleanup`.
  -- 2. calls `Enter()`
  {- TODO: `delta below` -}
  -- 3. block pointing to `delta` is pushed.
  -- 4. the result of calling the enter method is pushed onto the stack.
  --
  -- The next opcode will either ignore it (`PopTop`),
  -- or store it in variable (StoreFast, StoreName, or UnpackSequence).
  | SetupWith(delta)

  -- Cleans up the stack when a `with` statement block exits.
  --
  -- TOS is the context manager’s `__exit__()` bound method.
  -- Below TOS are 1–3 values indicating how/why the finally clause was entered:
  -- - `SECOND = None`
  -- - `(SECOND, THIRD) = (WHY_{RETURN,CONTINUE}), retval`
  -- - `SECOND = WHY_*; no retval below it`
  -- - `(SECOND, THIRD, FOURTH) = exc_info()`
  -- In the last case, `TOS(SECOND, THIRD, FOURTH)` is called,
  -- otherwise `TOS(None, None, None)`.
  -- Pushes `SECOND` and result of the call to the stack.
  | WithCleanupStart

  {- TODO: doc -}
  -- Pops exception type and result of ‘exit’ function call from the stack.
  --
  -- If the stack represents an exception, and the function call returns a ‘true’ value,
  -- this information is “zapped” and replaced with a single WhySilenced to prevent EndFinally from re-raising the exception.
  -- (But non-local gotos will still be resumed.)
  | WithCleanupFinish

  -- Resolves `AEnter` and `AExit` from the object on top of the stack.
  -- Pushes `AExit` and result of `AEnter()` to the stack.
  | BeforeAsyncWith
  -- Creates a new frame object.
  | SetupAsyncWith

{- ---- -}
{- Jump -}
{- ---- -}

  {- TODO: Probably use Label -}

  -- Increments bytecode counter by delta.
  | JumpForward(delta)
  -- Set bytecode counter to target.
  | JumpAbsolute(target)

  -- If TOS is true, sets the bytecode counter to target. TOS is popped.
  | PopJumpIfTrue(target)
  -- If TOS is false, sets the bytecode counter to target. TOS is popped.
  | PopJumpIfFalse(target)
  -- If TOS is true, sets the bytecode counter to target and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.
  | JumpIfTrueOrPop(target)
  -- If TOS is false, sets the bytecode counter to target and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.
  | JumpIfFalseOrPop(target)

{- ------ -}
{- String -}
{- ------ -}

  -- Used for implementing formatted literal strings (f-strings).
  --
  -- Pops an optional `FmtSpec` from the stack, then a required value.
  -- `flags` is interpreted as follows:
  -- - `(flags & 0x03) == 0x00`: value is formatted as-is.
  -- - `(flags & 0x03) == 0x01`: call `str()` on value before formatting it.
  -- - `(flags & 0x03) == 0x02`: call `repr()` on value before formatting it.
  -- - `(flags & 0x03) == 0x03`: call `ascii()` on value before formatting it.
  -- - `(flags & 0x04) == 0x04`: pop `FmtSpec` from the stack and use it, else use an empty `FmtSpec`.
  -- Formatting is performed using `PyobjectFormat()`.
  -- The result is pushed on the stack.
  | FormatValue(flags)

  -- Concatenates `count` strings from the stack
  -- and pushes the resulting string onto the stack.
  | BuildString(count)

{- ----- -}
{- Other -}
{- ----- -}

  -- Checks whether Annotations is defined in locals(), if not it is set up to an empty dict.
    -- This opcode is only emitted if a class or module body contains variable annotations statically.
  | SetupAnnotations

  -- Removes one block from the block stack.
  -- Per frame, there is a stack of blocks, denoting nested loops, try statements, and such.
  | PopBlock

  {- TODO: docs -}
  -- Pushes a reference to the cell contained in slot i of the cell and free variable storage.
  -- The name of the variable is CoCellvars[i] if i is less than the length of CoCellvars.
    -- Otherwise it is CoFreevars[i - len(CoCellvars)].
  | LoadClosure(i)

  -- Pushes a slice object on the stack.
  -- `argc` must be 2 or 3.
  -- If it is 2, `slice(TOS1, TOS)` is pushed;
  -- if it is 3, `slice(TOS2, TOS1, TOS)` is pushed.
  -- See the `slice()` built-in function for more information.
  | BuildSlice(UInt argc)
