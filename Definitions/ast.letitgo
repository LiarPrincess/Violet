{-
Quick tips:
- Use Haskell syntax highlighting
- Use block comments (the one starting with braces) for Elsa comments
- Use single line comments (the one starting with --) for Swift documentation

Most of the documentation was taken from:
https://greentreesnakes.readthedocs.io/en/latest/nodes.html
-}

@alias int = BigInt
@alias identifier = String
@alias string     = String
@alias object   = Any
@alias constant = Any

{- less typing (also CPython used those and we are lazy) -}
@alias expr = Expression
@alias exprKind = ExpressionKind
@alias stmt = Statement
@alias stmtKind = StatementKind
@alias loc = SourceLocation

-- Tree model of an entire program.
--
-- See:
-- - [Official docs](https://docs.python.org/3/reference/index.html)
-- - [greentreesnakes](https://greentreesnakes.readthedocs.io/en/latest/nodes.html)
@struct AST: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,
  -- Type of the statement.
  ASTKind kind,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- Top (root) node in AST.
-- Represents the whole program.
@enum ASTKind: Equatable =
  -- Used for input in interactive mode.
  -- `interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE`
  Single(stmt*)
  -- Used for all input read from non-interactive files.
  -- For example:
  -- - when parsing a complete Python program (from a file or from a string);
  -- - when parsing a module;
  -- - when parsing a string passed to the `exec()` function;\n
  -- `file_input ::=  (NEWLINE | statement)*`
  | FileInput(stmt*)
  -- Used for `eval()`.
  -- It ignores leading whitespace.
  -- `eval_input ::= expression_list NEWLINE*`
  | Expression(expr)

-- Syntactic unit that expresses some action to be carried out.
--
-- See:
-- - [Simple statement](https://docs.python.org/3/reference/simple_stmts.html)
-- - [Compound statement](https://docs.python.org/3/reference/compound_stmts.html)
@struct stmt: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,
  -- Type of the statement.
  stmtKind kind,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- Syntactic unit that expresses some action to be carried out.
--
-- See:
-- - [Simple statement](https://docs.python.org/3/reference/simple_stmts.html)
-- - [Compound statement](https://docs.python.org/3/reference/compound_stmts.html)
@enum stmtKind: Equatable =
  -- A function definition.
  -- - `name` is a raw string of the function name.
  -- - `args` is a arguments node.
  -- - `body` is the list of nodes inside the function.
  -- - `decoratorList` is the list of decorators to be applied,
  --    stored outermost first (i.e. the first in the list will be applied last).
  -- - `returns` is the return annotation (the thing after '->').
  FunctionDef(identifier name,
              arguments args,
              stmt+ body,
              expr* decoratorList,
              expr? returns)
  -- An async def function definition.
  -- Has the same fields as `FunctionDef`.
  | AsyncFunctionDef(identifier name,
                     arguments args,
                     stmt+ body,
                     expr* decoratorList,
                     expr? returns)

  -- A class definition.
  -- - `name` is a raw string for the class name
  -- - `bases` is a list of nodes for explicitly specified base classes.
  -- - `keywords` is a list of keyword nodes, principally for ‘metaclass’.
  --    Other keywords will be passed to the metaclass, as per PEP-3115.
  -- - `starargs` and kwargs are each a single node, as in a function call.
  --    starargs will be expanded to join the list of base classes, and kwargs will be passed to the metaclass.
  -- - `body` is a list of nodes representing the code within the class definition.
  -- - `decoratorList` is a list of nodes, as in `FunctionDef`.
  | ClassDef(identifier name,
             expr* bases,
             keyword* keywords,
             stmt+ body,
             expr* decoratorList)

  -- A `return` statement.
  | Return(expr?)
  -- Represents a `del` statement.
  -- Contains a list of nodes, such as Name, Attribute or Subscript nodes.
  | Delete(expr+)

  -- An assignment.
  -- - `targets` is a list of nodes
  -- - `value` is a single node\n
  -- Multiple nodes in targets represents assigning the same value to each.
  -- Unpacking is represented by putting a Tuple or List within targets.
  | Assign(expr+ targets, expr value)
  -- Augmented assignment, such as `a += 1`.
  -- - `target` is a Name node for `a`. Target can be Name, Subscript
  -- or Attribute, but not a Tuple or List (unlike the targets of `Assign`).
  -- - `op` is an operation (for example `Add`)
  -- - `value` is the operand (for example Num node for 1)
  | AugAssign(expr target, BinaryOperator op, expr value)
  -- An assignment with a type annotation.
  -- - `target` is a single node and can be a Name, a Attribute or a Subscript
  -- - `annotation` is the annotation, such as a Str or Name node
  -- - `value` is a single optional node
  -- - `simple` indicates that `target`
  -- does not appear in between parenthesis (which excludes single element tuple)
  -- and is pure name and not expression (which excludes `tangled.rapunzel`).
  | AnnAssign(expr target, expr annotation, expr? value, Bool isSimple)

  -- A `for` loop.
  -- - `target` holds the variable(s) the loop assigns to, as a single Name, Tuple or List node.
  -- - `iter` holds the item to be looped over, again as a single node.
  -- - `body` and `orElse` contain lists of nodes to execute. Those in orElse
  -- are executed if the loop finishes normally, rather than via a break statement.
  | For(expr target, expr iter, stmt+ body, stmt* orElse)
  -- An `async for` definition.
  -- Has the same fields as `For`.
  | AsyncFor(expr target, expr iter, stmt+ body, stmt* orElse)
  -- A `while` loop.
  -- - `test` holds the condition, such as a Compare node.
  | While(expr test, stmt+ body, stmt* orElse)

  -- An if statement.
  -- - `test` holds a single node, such as a Compare node.
  -- - `body` and `orElse` each hold a list of nodes.
  -- - `elif` clauses don’t have a special representation in the AST,
  -- but rather appear as extra `If` nodes within the `orElse` section
  -- of the previous one.
  | If(expr test, stmt+ body, stmt* orElse)

  -- A `with` block.
  -- - `items` is a list of withitem nodes representing the context managers.
  -- - `body` is the indented block inside the context.
  | With(WithItem+ items, stmt+ body)
  -- An `async with` definition.
  -- Has the same fields as `With`.
  | AsyncWith(WithItem+ items, stmt+ body)

  -- Raising an exception.
  -- - `exception` is the exception object to be raised, normally a Call or Name
  -- or None for a standalone raise.
  -- - `cause` is the optional part for y in raise x from y.
  | Raise(expr? exception, expr? cause)
  -- `try` block.
  -- All attributes are list of nodes to execute, except for handlers,
  -- which is a list of ExceptHandler nodes.
  | Try(stmt+ body, ExceptHandler* handlers, stmt* orElse, stmt* finalBody)
  -- An assertion.
  -- - `test` holds the condition, such as a Compare node.
  -- - `msg` holds the failure message, normally a Str node.
  | Assert(expr test, expr? msg)

  -- An import statement.
  -- Contains a list of alias nodes.
  | Import(Alias+)
  -- Represents `from x import y`.
  -- - `moduleName` is a raw string of the ‘from’ name, without any leading dots
  -- or None for statements such as `from . import foo`.
  -- - `level` is an integer holding the level of the relative import
  -- (0 means absolute import).
  | ImportFrom(identifier? moduleName, Alias+ names, UInt8 level)

  -- `global` statement.
  | Global(identifier+)
  -- `nonlocal` statement.
  | Nonlocal(identifier+)
  -- `Expression` statement.
  | Expr(expr)
  -- A `pass` statement.
  | Pass
  -- `break` statement.
  | Break
  -- `continue` statement.
  | Continue

-- Import name with optional 'as' alias.
-- Both parameters are raw strings of the names.
-- `asname` can be None if the regular name is to be used.
@struct Alias: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,
  identifier name,
  identifier? asName,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- A single context manager in a `with` block.
@struct WithItem: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,
  -- Context manager (often a Call node).
  expr contextExpr,
  -- Name, Tuple or List for the `as foo` part, or `nil` if that isn’t used.
  expr? optionalVars,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- A single except clause.
@struct ExceptHandler: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,
  -- Exception type it will match, typically a Name node
  -- (or `nil` for a catch-all except: clause).
  expr? type,
  -- Raw string for the name to hold the exception,
  -- or `nil` if the clause doesn’t have as foo.
  identifier? name,
  -- List of handler nodes.
  stmt+ body,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- Combination of one or more constants, variables, operators and functions
-- that the programming language interprets and computes to produce another value.
--
-- See: [docs](https://docs.python.org/3/reference/expressions.html)
@struct expr: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,
  -- Type of the expression.
  exprKind kind,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- Combination of one or more constants, variables, operators and functions
-- that the programming language interprets and computes to produce another value.
--
-- See: [docs](https://docs.python.org/3/reference/expressions.html)
@indirect exprKind: Equatable =
{- Base -}
  True
  | False
  | None
  | Ellipsis
{- Literals -}
  | Identifier(String)
  | String(StringGroup)
  | Int(BigInt)
  | Float(Double)
  | Complex(Double real, Double imag)
  | Bytes(Data)
{- Operators -}
  -- Operation with single operand.
  | UnaryOp(UnaryOperator, expr right)
  -- Operation with 2 operands.
  | BinaryOp(BinaryOperator, expr left, expr right)
  -- Operation with logical values as operands.
  -- Returns last evaluated argument (even if it's not strictly `True` or `False`).
  -- - Note:
  -- Following values are interpreted as false:
  -- - False\n- None\n- numeric zero\n- empty strings\n- empty containers
  | BoolOp(BooleanOperator, expr left, expr right)
  {- need sequence to distinguish between: x < 4 < 3 and (x < 4) < 3 -}
  | Compare(expr left, ComparisonElement+ elements)
{- Collections -}
  -- Values separated by commas (sometimes between parentheses): (a,b).
  | Tuple(expr*)
  -- List of comma-separated values between square brackets: [a,b].
  | List(expr*)
  -- Set of `key: value` pairs between braces: {a: b}. Keys are unique.
  | Dictionary(DictionaryElement*)
  -- List of comma-separated values between braces: {a}. Unordered with no duplicates.
  | Set(expr*)
{- Comprehensions -}
  -- Brackets containing an expression followed by a for clause and then
  -- zero or more for or if clauses.
  -- `elt` - expression that will be evaluated for each item
  | ListComprehension(expr elt, comprehension+ generators)
  -- Brackets containing an expression followed by a for clause and then
  -- zero or more for or if clauses.
  -- `elt` - expression that will be evaluated for each item
  | SetComprehension(expr elt, comprehension+ generators)
  -- Brackets containing an expression followed by a for clause and then
  -- zero or more for or if clauses.
  -- `key` and `value` - expressions that will be evaluated for each item
  | DictionaryComprehension(expr key, expr value, comprehension+ generators)
  {- the grammar constrains where yield expressions can occur -}
  -- Expression followed by a for clause and then
  -- zero or more for or if clauses.
  -- `elt` - expression that will be evaluated for each item
  | GeneratorExp(expr elt, comprehension+ generators)
{- Generators/coroutines -}
  -- An await expression.
  -- `value` is what it waits for.\n
  -- Only valid in the body of an AsyncFunctionDef.
  | Await(expr)
  -- A `yield` or `yield from` expression.
  -- Because these are expressions, they must be wrapped in a `Expr` node
  -- if the value sent back is not used.
  | Yield(expr?)
  -- A `yield` or `yield from` expression.
  -- Because these are expressions, they must be wrapped in a `Expr` node
  -- if the value sent back is not used.
  | YieldFrom(expr)
{- Functions -}
  -- Minimal function definition that can be used inside an expression.
  -- Unlike FunctionDef, body holds a single node.
  | Lambda(arguments args, expr body)
  -- A function call.
  -- - `func` - function to call
  -- - `args` - arguments passed by position
  -- - `keywords` - keyword objects representing arguments passed by keyword
  | Call(expr function, expr* args, keyword* keywords)
{- Other -}
  -- For example: `1 if True else 2`
  | IfExpression(expr test, expr body, expr orElse)
  -- For example `apple.juice = poison`.
  | Attribute(expr, identifier name)
  -- For example `apple[juice] = poison`.
  | Subscript(expr, slice slice)
  -- For example:
  -- `dwarfs = ["Doc", "Grumpy", "Happy", "Sleepy", "Bashful", "Sneezy", "Dopey"]`
  -- `singSong(*dwarfs)`
  | Starred(expr)

@enum UnaryOperator: Equatable =
  -- Bitwise inversion of its integer argument.
  -- Only applies to integral numbers.
  Invert
  -- True if its argument is false, False otherwise.
  | Not
  -- Unchanged argument. CPython: UAdd (unary add).
  | Plus
  -- Negation of its numeric argument. CPython: USub (unary sub).
  | Minus

@enum BooleanOperator: Equatable =
  -- Logical `and` with short-circuit.
  And
  -- Logical `or` with short-circuit.
  | Or

@enum BinaryOperator: Equatable =
  -- Sum of its arguments.
  -- - Numbers added together.
  -- - Sequences are concatenated.
  Add
  -- Difference of its arguments.
  | Sub
  -- Product of its arguments.
  -- - Numbers multiplied together.
  -- - For integer and sequence repetition is performed.
  | Mul
  -- Intended to be used for matrix multiplication.
  -- No builtin Python types implement this operator.
  | MatMul
  -- Quotient of their arguments.
  -- Division of integers yields a float.
  | Div
  -- Remainder from the division of the first argument by the second.
  | Modulo
  -- Left argument raised to the power of its right argument.
  | Pow
  -- Shift the first argument to the left by the number of bits
  -- given by the second argument.
  | LeftShift
  -- Shift the first argument to the right by the number of bits
  -- given by the second argument.
  | RightShift
  -- Bitwise (inclusive) OR of its arguments, which must be integers.
  | BitOr
  -- Bitwise XOR (exclusive OR) of its arguments, which must be integers.
  | BitXor
  -- Bitwise AND of its arguments, which must be integers.
  | BitAnd
  -- Quotient of their arguments.
  -- Floor division of integers results in an integer.
  | FloorDiv

@struct ComparisonElement: Equatable = (
  ComparisonOperator op,
  expr right
)

@enum ComparisonOperator: Equatable =
  -- True when two operands are equal.
  Equal
  -- True when two operands are not equal.
  | NotEqual
  -- True when left operand is less than the value of right operand.
  | Less
  -- True when left operand is less than or equal to the value of right operand.
  | LessEqual
  -- True when left operand is greater than the value of right operand.
  | Greater
  -- True when left operand is greater than or equal to the value of right operand.
  | GreaterEqual
  -- True when x and y are the same object.
  | Is
  -- Negation of `x is y`.
  | IsNot
  -- True when x is a member of s.
  | In
  -- Negation of `x in s`
  | NotIn

@enum DictionaryElement: Equatable =
  -- `**expr`
    unpacking(expr)
  -- `key : value`
  | keyValue(expr key, expr value)

{- Based on RustPython. -}
{- CPython uses 'JoinedStr(expr* values)', but we know that values are strings. -}
-- For normal strings and f-strings, concatenate them together.
@enum StringGroup: Equatable =
  -- String - no f-strings.
  Literal(String)
  -- FormattedValue - just an f-string (with no leading or trailing literals).
  | FormattedValue(expr, ConversionFlag? conversion, String? spec)
  -- JoinedStr - if there are multiple f-strings or any literals involved.
  | Joined(StringGroup*)

-- Transforms a value prior to formatting it.
@enum ConversionFlag: Equatable =
  -- Converts by calling `str(<value>)`.
  Str
  -- Converts by calling `ascii(<value>)`.
  | Ascii
  -- Converts by calling `repr(<value>)`.
  | Repr

@struct Slice: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,

  sliceKind kind,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

@enum SliceKind: Equatable =
  -- Regular slicing: `movies[pinocchio:frozen2]`.
  Slice(expr? lower, expr? upper, expr? step)
  -- Advanced slicing: `frozen[kristoff:ana, olaf]`.
  -- `value` holds a list of `Slice` and `Index` nodes.
  | ExtSlice(Slice+)
  -- Subscripting with a single value: `frozen[elsa]`.
  | Index(expr)

-- One `for` clause in a comprehension.
@struct Comprehension: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,

  -- Reference to use for each element,
  -- typically a `Identifier` or `Tuple` node.
  expr target,
  -- Object to iterate over.
  expr iter,
  -- List of test expressions. We can have multiple `ifs`.
  expr* ifs,
  -- Indicates that the comprehension is asynchronous.
  Bool isAsync,

  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- The arguments for a function passed by value
-- (where the value is always an object reference, not the value of the object).
-- https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions"
@struct Arguments: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,

  -- Function positional arguments.
  -- When a function is called, positional arguments are mapped
  -- to these parameters based solely on their position.
  arg* args,
  -- Default values for positional arguments.
  -- If there are fewer defaults, they correspond to the last *n* arguments.
  -- - Important: The default value is evaluated only **once**.
  expr* defaults,

  -- Non-keyworded variable length arguments.
  -- By convention called `*args`.
  vararg vararg,
  -- Parameters which occur after the '*args'.
  -- Can only be used as keywords rather than positional arguments.
  -- CPython `kwonlyargs`.
  arg* kwOnlyArgs,
  -- Default values for keyword-only arguments.
  -- If no default value is specified then implicit `None` is assumed.
  -- CPython `kw_defaults`.
  -- - Important: The default value is evaluated only **once**.
  expr* kwOnlyDefaults,

  -- Keyworded (named) variable length arguments.
  -- By convention called `**kwargs`.
  arg? kwarg,

  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

@struct Arg: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,

  -- Argument name.
  identifier name,
  -- Python expression evaluated at compile time.
  -- Not used during runtime, can be used by third party libraries.
  -- Introduced in PEP 3107.
  expr? annotation,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

@enum Vararg: Equatable =
  none
  -- Separator for keyword arguments. Represented by just `*`.
  | unnamed
  | named(Arg)

-- A keyword argument to a function call or class definition.
-- `nil` name is used for `**kwargs`.
@struct Keyword: ASTNode = (
  -- A unique node identifier.
  -- Mostly used for efficient Equatable/Hashable implementation.
  NodeId id,

  -- Parameter name.
  identifier? name,
  -- Node to pass in.
  expr value,

  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)
