// This file was auto-generated by Elsa from 'ast.letitgo' using 'ast-destruct' command.
// DO NOT EDIT!

import XCTest
import Core
import Lexer
import Parser

// swiftlint:disable file_length
// swiftlint:disable large_tuple
// swiftlint:disable vertical_whitespace_closing_braces
// swiftlint:disable trailing_newline

// MARK: - ExpressionKind

protocol DestructExpressionKind { }

extension DestructExpressionKind {

  internal func destructIdentifier(_ expr: Expression,
                                   file:   StaticString = #file,
                                   line:   UInt         = #line) ->
    (String)? {

    if case let ExpressionKind.identifier(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructInt(_ expr: Expression,
                            file:   StaticString = #file,
                            line:   UInt         = #line) ->
    (PyInt)? {

    if case let ExpressionKind.int(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructFloat(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Double)? {

    if case let ExpressionKind.float(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructComplex(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (real: Double, imag: Double)? {

    if case let ExpressionKind.complex(real: value0, imag: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructBytes(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Data)? {

    if case let ExpressionKind.bytes(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructUnaryOp(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (UnaryOperator, right: Expression)? {

    if case let ExpressionKind.unaryOp(value0, right: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructBinaryOp(_ expr: Expression,
                                 file:   StaticString = #file,
                                 line:   UInt         = #line) ->
    (BinaryOperator, left: Expression, right: Expression)? {

    if case let ExpressionKind.binaryOp(value0, left: value1, right: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructBoolOp(_ expr: Expression,
                               file:   StaticString = #file,
                               line:   UInt         = #line) ->
    (BooleanOperator, left: Expression, right: Expression)? {

    if case let ExpressionKind.boolOp(value0, left: value1, right: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructCompare(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (left: Expression, elements: [ComparisonElement])? {

    if case let ExpressionKind.compare(left: value0, elements: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructTuple(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    ([Expression])? {

    if case let ExpressionKind.tuple(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructList(_ expr: Expression,
                             file:   StaticString = #file,
                             line:   UInt         = #line) ->
    ([Expression])? {

    if case let ExpressionKind.list(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructDictionary(_ expr: Expression,
                                   file:   StaticString = #file,
                                   line:   UInt         = #line) ->
    ([DictionaryElement])? {

    if case let ExpressionKind.dictionary(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructSet(_ expr: Expression,
                            file:   StaticString = #file,
                            line:   UInt         = #line) ->
    ([Expression])? {

    if case let ExpressionKind.set(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructListComprehension(_ expr: Expression,
                                          file:   StaticString = #file,
                                          line:   UInt         = #line) ->
    (elt: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.listComprehension(elt: value0, generators: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructSetComprehension(_ expr: Expression,
                                         file:   StaticString = #file,
                                         line:   UInt         = #line) ->
    (elt: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.setComprehension(elt: value0, generators: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructDictionaryComprehension(_ expr: Expression,
                                                file:   StaticString = #file,
                                                line:   UInt         = #line) ->
    (key: Expression, value: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.dictionaryComprehension(key: value0, value: value1, generators: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructGeneratorExp(_ expr: Expression,
                                     file:   StaticString = #file,
                                     line:   UInt         = #line) ->
    (elt: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.generatorExp(elt: value0, generators: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructAwait(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Expression)? {

    if case let ExpressionKind.await(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructYield(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Expression?)? {

    if case let ExpressionKind.yield(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructYieldFrom(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (Expression)? {

    if case let ExpressionKind.yieldFrom(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructLambda(_ expr: Expression,
                               file:   StaticString = #file,
                               line:   UInt         = #line) ->
    (args: Arguments, body: Expression)? {

    if case let ExpressionKind.lambda(args: value0, body: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructCall(_ expr: Expression,
                             file:   StaticString = #file,
                             line:   UInt         = #line) ->
    (func: Expression, args: [Expression], keywords: [Keyword])? {

    if case let ExpressionKind.call(func: value0, args: value1, keywords: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructNamedExpr(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (target: Expression, value: Expression)? {

    if case let ExpressionKind.namedExpr(target: value0, value: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructIfExpression(_ expr: Expression,
                                     file:   StaticString = #file,
                                     line:   UInt         = #line) ->
    (test: Expression, body: Expression, orElse: Expression)? {

    if case let ExpressionKind.ifExpression(test: value0, body: value1, orElse: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructAttribute(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (Expression, name: String)? {

    if case let ExpressionKind.attribute(value0, name: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructSubscript(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (Expression, slice: Slice)? {

    if case let ExpressionKind.subscript(value0, slice: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructStarred(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (Expression)? {

    if case let ExpressionKind.starred(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

}

// MARK: - SliceKind

protocol DestructSliceKind { }

extension DestructSliceKind {

  internal func destructSubscriptSlice(_ expr: Expression,
                                       file:   StaticString = #file,
                                       line:   UInt         = #line) ->
    (slice: Slice, lower: Expression?, upper: Expression?, step: Expression?)? {

    guard case let ExpressionKind.subscript(_, slice: slice) = expr.kind else {
      XCTAssertTrue(false, expr.kind.description, file: file, line: line)
      return nil
    }

    switch slice.kind {
    case let .slice(lower: value0, upper: value1, step: value2):
      return (slice, value0, value1, value2)
    default:
      XCTAssertTrue(false, slice.kind.description, file: file, line: line)
      return nil
    }
  }

  internal func destructSubscriptExtSlice(_ expr: Expression,
                                          file:   StaticString = #file,
                                          line:   UInt         = #line) ->
    (slice: Slice, dims: [Slice])? {

    guard case let ExpressionKind.subscript(_, slice: slice) = expr.kind else {
      XCTAssertTrue(false, expr.kind.description, file: file, line: line)
      return nil
    }

    switch slice.kind {
    case let .extSlice(dims: value0):
      return (slice, value0)
    default:
      XCTAssertTrue(false, slice.kind.description, file: file, line: line)
      return nil
    }
  }

  internal func destructSubscriptIndex(_ expr: Expression,
                                       file:   StaticString = #file,
                                       line:   UInt         = #line) ->
    (slice: Slice, Expression)? {

    guard case let ExpressionKind.subscript(_, slice: slice) = expr.kind else {
      XCTAssertTrue(false, expr.kind.description, file: file, line: line)
      return nil
    }

    switch slice.kind {
    case let .index(value0):
      return (slice, value0)
    default:
      XCTAssertTrue(false, slice.kind.description, file: file, line: line)
      return nil
    }
  }

}

