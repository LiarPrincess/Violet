// This file was auto-generated by Elsa from 'ast.letitgo' using 'ast-destruct' command.
// DO NOT EDIT!

import XCTest
import Core
import Lexer
import Parser

// swiftlint:disable file_length
// swiftlint:disable large_tuple
// swiftlint:disable vertical_whitespace_closing_braces
// swiftlint:disable trailing_newline

// MARK: - AST

protocol DestructAST { }

extension DestructAST {

  internal func destructSingle(_ ast: AST,
                               file:   StaticString = #file,
                               line:   UInt         = #line) ->
  ([Statement])? {

    if case let AST.single(value0) = ast {
      return (value0)
    }

    XCTAssertTrue(false, String(describing: ast), file: file, line: line)
    return nil
  }

  internal func destructFileInput(_ ast: AST,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
  ([Statement])? {

    if case let AST.fileInput(value0) = ast {
      return (value0)
    }

    XCTAssertTrue(false, String(describing: ast), file: file, line: line)
    return nil
  }

  internal func destructExpression(_ ast: AST,
                                   file:   StaticString = #file,
                                   line:   UInt         = #line) ->
  (Expression)? {

    if case let AST.expression(value0) = ast {
      return (value0)
    }

    XCTAssertTrue(false, String(describing: ast), file: file, line: line)
    return nil
  }

}

// MARK: - ExpressionKind

protocol DestructExpressionKind { }

extension DestructExpressionKind {

  internal func destructIdentifier(_ expr: Expression,
                                   file:   StaticString = #file,
                                   line:   UInt         = #line) ->
    (String)? {

    if case let ExpressionKind.identifier(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructString(_ expr: Expression,
                               file:   StaticString = #file,
                               line:   UInt         = #line) ->
    (StringGroup)? {

    if case let ExpressionKind.string(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructInt(_ expr: Expression,
                            file:   StaticString = #file,
                            line:   UInt         = #line) ->
    (PyInt)? {

    if case let ExpressionKind.int(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructFloat(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Double)? {

    if case let ExpressionKind.float(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructComplex(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (real: Double, imag: Double)? {

    if case let ExpressionKind.complex(real: value0, imag: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructBytes(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Data)? {

    if case let ExpressionKind.bytes(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructUnaryOp(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (UnaryOperator, right: Expression)? {

    if case let ExpressionKind.unaryOp(value0, right: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructBinaryOp(_ expr: Expression,
                                 file:   StaticString = #file,
                                 line:   UInt         = #line) ->
    (BinaryOperator, left: Expression, right: Expression)? {

    if case let ExpressionKind.binaryOp(value0, left: value1, right: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructBoolOp(_ expr: Expression,
                               file:   StaticString = #file,
                               line:   UInt         = #line) ->
    (BooleanOperator, left: Expression, right: Expression)? {

    if case let ExpressionKind.boolOp(value0, left: value1, right: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructCompare(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (left: Expression, elements: [ComparisonElement])? {

    if case let ExpressionKind.compare(left: value0, elements: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructTuple(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    ([Expression])? {

    if case let ExpressionKind.tuple(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructList(_ expr: Expression,
                             file:   StaticString = #file,
                             line:   UInt         = #line) ->
    ([Expression])? {

    if case let ExpressionKind.list(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructDictionary(_ expr: Expression,
                                   file:   StaticString = #file,
                                   line:   UInt         = #line) ->
    ([DictionaryElement])? {

    if case let ExpressionKind.dictionary(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructSet(_ expr: Expression,
                            file:   StaticString = #file,
                            line:   UInt         = #line) ->
    ([Expression])? {

    if case let ExpressionKind.set(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructListComprehension(_ expr: Expression,
                                          file:   StaticString = #file,
                                          line:   UInt         = #line) ->
    (elt: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.listComprehension(elt: value0, generators: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructSetComprehension(_ expr: Expression,
                                         file:   StaticString = #file,
                                         line:   UInt         = #line) ->
    (elt: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.setComprehension(elt: value0, generators: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructDictionaryComprehension(_ expr: Expression,
                                                file:   StaticString = #file,
                                                line:   UInt         = #line) ->
    (key: Expression, value: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.dictionaryComprehension(key: value0, value: value1, generators: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructGeneratorExp(_ expr: Expression,
                                     file:   StaticString = #file,
                                     line:   UInt         = #line) ->
    (elt: Expression, generators: [Comprehension])? {

    if case let ExpressionKind.generatorExp(elt: value0, generators: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructAwait(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Expression)? {

    if case let ExpressionKind.await(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructYield(_ expr: Expression,
                              file:   StaticString = #file,
                              line:   UInt         = #line) ->
    (Expression?)? {

    if case let ExpressionKind.yield(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructYieldFrom(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (Expression)? {

    if case let ExpressionKind.yieldFrom(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructLambda(_ expr: Expression,
                               file:   StaticString = #file,
                               line:   UInt         = #line) ->
    (args: Arguments, body: Expression)? {

    if case let ExpressionKind.lambda(args: value0, body: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructCall(_ expr: Expression,
                             file:   StaticString = #file,
                             line:   UInt         = #line) ->
    (func: Expression, args: [Expression], keywords: [Keyword])? {

    if case let ExpressionKind.call(func: value0, args: value1, keywords: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructNamedExpr(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (target: Expression, value: Expression)? {

    if case let ExpressionKind.namedExpr(target: value0, value: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructIfExpression(_ expr: Expression,
                                     file:   StaticString = #file,
                                     line:   UInt         = #line) ->
    (test: Expression, body: Expression, orElse: Expression)? {

    if case let ExpressionKind.ifExpression(test: value0, body: value1, orElse: value2) = expr.kind {
      return (value0, value1, value2)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructAttribute(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (Expression, name: String)? {

    if case let ExpressionKind.attribute(value0, name: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructSubscript(_ expr: Expression,
                                  file:   StaticString = #file,
                                  line:   UInt         = #line) ->
    (Expression, slice: Slice)? {

    if case let ExpressionKind.subscript(value0, slice: value1) = expr.kind {
      return (value0, value1)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

  internal func destructStarred(_ expr: Expression,
                                file:   StaticString = #file,
                                line:   UInt         = #line) ->
    (Expression)? {

    if case let ExpressionKind.starred(value0) = expr.kind {
      return (value0)
    }

    XCTAssertTrue(false, expr.kind.description, file: file, line: line)
    return nil
  }

}

// MARK: - StringGroup

protocol DestructStringGroup { }

extension DestructStringGroup {

  internal func destructStringSimple(_ group: StringGroup,
                                     file:   StaticString = #file,
                                     line:   UInt         = #line) ->
    (String)? {

    switch group {
    case let .string(value0):
      return (value0)
    default:
      XCTAssertTrue(false, String(describing: group), file: file, line: line)
      return nil
    }
  }

  internal func destructStringFormattedValue(_ group: StringGroup,
                                             file:   StaticString = #file,
                                             line:   UInt         = #line) ->
    (String, conversion: ConversionFlag?, spec: String?)? {

    switch group {
    case let .formattedValue(value0, conversion: value1, spec: value2):
      return (value0, value1, value2)
    default:
      XCTAssertTrue(false, String(describing: group), file: file, line: line)
      return nil
    }
  }

  internal func destructStringJoinedString(_ group: StringGroup,
                                           file:   StaticString = #file,
                                           line:   UInt         = #line) ->
    ([StringGroup])? {

    switch group {
    case let .joinedString(value0):
      return (value0)
    default:
      XCTAssertTrue(false, String(describing: group), file: file, line: line)
      return nil
    }
  }

}

// MARK: - SliceKind

protocol DestructSliceKind { }

extension DestructSliceKind {

  internal func destructSubscriptSlice(_ expr: Expression,
                                       file:   StaticString = #file,
                                       line:   UInt         = #line) ->
    (slice: Slice, lower: Expression?, upper: Expression?, step: Expression?)? {

    guard case let ExpressionKind.subscript(_, slice: slice) = expr.kind else {
      XCTAssertTrue(false, expr.kind.description, file: file, line: line)
      return nil
    }

    switch slice.kind {
    case let .slice(lower: value0, upper: value1, step: value2):
      return (slice, value0, value1, value2)
    default:
      XCTAssertTrue(false, slice.kind.description, file: file, line: line)
      return nil
    }
  }

  internal func destructSubscriptExtSlice(_ expr: Expression,
                                          file:   StaticString = #file,
                                          line:   UInt         = #line) ->
    (slice: Slice, dims: [Slice])? {

    guard case let ExpressionKind.subscript(_, slice: slice) = expr.kind else {
      XCTAssertTrue(false, expr.kind.description, file: file, line: line)
      return nil
    }

    switch slice.kind {
    case let .extSlice(dims: value0):
      return (slice, value0)
    default:
      XCTAssertTrue(false, slice.kind.description, file: file, line: line)
      return nil
    }
  }

  internal func destructSubscriptIndex(_ expr: Expression,
                                       file:   StaticString = #file,
                                       line:   UInt         = #line) ->
    (slice: Slice, Expression)? {

    guard case let ExpressionKind.subscript(_, slice: slice) = expr.kind else {
      XCTAssertTrue(false, expr.kind.description, file: file, line: line)
      return nil
    }

    switch slice.kind {
    case let .index(value0):
      return (slice, value0)
    default:
      XCTAssertTrue(false, slice.kind.description, file: file, line: line)
      return nil
    }
  }

}

