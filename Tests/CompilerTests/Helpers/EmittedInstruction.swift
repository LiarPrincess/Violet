// This file was auto-generated by Elsa from 'opcodes.letitgo'
// using 'code-object-test' command.
// DO NOT EDIT!

import Foundation
import Core
import Bytecode

// swiftlint:disable trailing_newline
// swiftlint:disable file_length
// swiftlint:disable vertical_whitespace_closing_braces

/// Expected emitted instruction.
struct EmittedInstruction {
  let kind: EmittedInstructionKind
  let arg:  String?

  init(_ kind: EmittedInstructionKind, _ arg:  String? = nil) {
    self.kind = kind
    self.arg  = arg
  }
}

/// Basically `Instruction`, but without associated values.
enum EmittedInstructionKind {
  case nop
  case popTop
  case rotTwo
  case rotThree
  case dupTop
  case dupTopTwo
  case unaryPositive
  case unaryNegative
  case unaryNot
  case unaryInvert
  case binaryPower
  case binaryMultiply
  case binaryMatrixMultiply
  case binaryFloorDivide
  case binaryTrueDivide
  case binaryModulo
  case binaryAdd
  case binarySubtract
  case binaryLShift
  case binaryRShift
  case binaryAnd
  case binaryXor
  case binaryOr
  case inplacePower
  case inplaceMultiply
  case inplaceMatrixMultiply
  case inplaceFloorDivide
  case inplaceTrueDivide
  case inplaceModulo
  case inplaceAdd
  case inplaceSubtract
  case inplaceLShift
  case inplaceRShift
  case inplaceAnd
  case inplaceXor
  case inplaceOr
  case compareOp
  case getAwaitable
  case getAIter
  case getANext
  case yieldValue
  case yieldFrom
  case printExpr
  case setupLoop
  case forIter
  case getIter
  case getYieldFromIter
  case `break`
  case `continue`
  case buildTuple
  case buildList
  case buildSet
  case buildMap
  case buildConstKeyMap
  case setAdd
  case listAppend
  case mapAdd
  case buildTupleUnpack
  case buildTupleUnpackWithCall
  case buildListUnpack
  case buildSetUnpack
  case buildMapUnpack
  case buildMapUnpackWithCall
  case unpackSequence
  case unpackEx
  case loadConst
  case storeName
  case loadName
  case deleteName
  case storeAttribute
  case loadAttribute
  case deleteAttribute
  case binarySubscript
  case storeSubscript
  case deleteSubscript
  case storeGlobal
  case loadGlobal
  case deleteGlobal
  case loadFast
  case storeFast
  case deleteFast
  case loadDeref
  case storeDeref
  case deleteDeref
  case loadClassDeref
  case makeFunction
  case callFunction
  case callFunctionKw
  case callFunctionEx
  case `return`
  case loadBuildClass
  case loadMethod
  case callMethod
  case importStar
  case importName
  case importFrom
  case popExcept
  case endFinally
  case setupExcept
  case setupFinally
  case raiseVarargs
  case setupWith
  case withCleanupStart
  case withCleanupFinish
  case beforeAsyncWith
  case setupAsyncWith
  case jumpAbsolute
  case popJumpIfTrue
  case popJumpIfFalse
  case jumpIfTrueOrPop
  case jumpIfFalseOrPop
  case formatValue
  case buildString
  case extendedArg
  case setupAnnotations
  case popBlock
  case loadClosure
  case buildSlice
}

extension Instruction {

  var asEmitted: EmittedInstruction {
    switch self {
    case .nop:
      return EmittedInstruction(.nop)
    case .popTop:
      return EmittedInstruction(.popTop)
    case .rotTwo:
      return EmittedInstruction(.rotTwo)
    case .rotThree:
      return EmittedInstruction(.rotThree)
    case .dupTop:
      return EmittedInstruction(.dupTop)
    case .dupTopTwo:
      return EmittedInstruction(.dupTopTwo)
    case .unaryPositive:
      return EmittedInstruction(.unaryPositive)
    case .unaryNegative:
      return EmittedInstruction(.unaryNegative)
    case .unaryNot:
      return EmittedInstruction(.unaryNot)
    case .unaryInvert:
      return EmittedInstruction(.unaryInvert)
    case .binaryPower:
      return EmittedInstruction(.binaryPower)
    case .binaryMultiply:
      return EmittedInstruction(.binaryMultiply)
    case .binaryMatrixMultiply:
      return EmittedInstruction(.binaryMatrixMultiply)
    case .binaryFloorDivide:
      return EmittedInstruction(.binaryFloorDivide)
    case .binaryTrueDivide:
      return EmittedInstruction(.binaryTrueDivide)
    case .binaryModulo:
      return EmittedInstruction(.binaryModulo)
    case .binaryAdd:
      return EmittedInstruction(.binaryAdd)
    case .binarySubtract:
      return EmittedInstruction(.binarySubtract)
    case .binaryLShift:
      return EmittedInstruction(.binaryLShift)
    case .binaryRShift:
      return EmittedInstruction(.binaryRShift)
    case .binaryAnd:
      return EmittedInstruction(.binaryAnd)
    case .binaryXor:
      return EmittedInstruction(.binaryXor)
    case .binaryOr:
      return EmittedInstruction(.binaryOr)
    case .inplacePower:
      return EmittedInstruction(.inplacePower)
    case .inplaceMultiply:
      return EmittedInstruction(.inplaceMultiply)
    case .inplaceMatrixMultiply:
      return EmittedInstruction(.inplaceMatrixMultiply)
    case .inplaceFloorDivide:
      return EmittedInstruction(.inplaceFloorDivide)
    case .inplaceTrueDivide:
      return EmittedInstruction(.inplaceTrueDivide)
    case .inplaceModulo:
      return EmittedInstruction(.inplaceModulo)
    case .inplaceAdd:
      return EmittedInstruction(.inplaceAdd)
    case .inplaceSubtract:
      return EmittedInstruction(.inplaceSubtract)
    case .inplaceLShift:
      return EmittedInstruction(.inplaceLShift)
    case .inplaceRShift:
      return EmittedInstruction(.inplaceRShift)
    case .inplaceAnd:
      return EmittedInstruction(.inplaceAnd)
    case .inplaceXor:
      return EmittedInstruction(.inplaceXor)
    case .inplaceOr:
      return EmittedInstruction(.inplaceOr)
    case let .compareOp(value0):
      return EmittedInstruction(.compareOp, String(describing: value0))
    case .getAwaitable:
      return EmittedInstruction(.getAwaitable)
    case .getAIter:
      return EmittedInstruction(.getAIter)
    case .getANext:
      return EmittedInstruction(.getANext)
    case .yieldValue:
      return EmittedInstruction(.yieldValue)
    case .yieldFrom:
      return EmittedInstruction(.yieldFrom)
    case .printExpr:
      return EmittedInstruction(.printExpr)
    case let .setupLoop(value0):
      return EmittedInstruction(.setupLoop, String(describing: value0))
    case let .forIter(value0):
      return EmittedInstruction(.forIter, String(describing: value0))
    case .getIter:
      return EmittedInstruction(.getIter)
    case .getYieldFromIter:
      return EmittedInstruction(.getYieldFromIter)
    case .`break`:
      return EmittedInstruction(.break)
    case let .`continue`(value0):
      return EmittedInstruction(.continue, String(describing: value0))
    case let .buildTuple(elementCount: value0):
      return EmittedInstruction(.buildTuple, String(describing: value0))
    case let .buildList(elementCount: value0):
      return EmittedInstruction(.buildList, String(describing: value0))
    case let .buildSet(elementCount: value0):
      return EmittedInstruction(.buildSet, String(describing: value0))
    case let .buildMap(elementCount: value0):
      return EmittedInstruction(.buildMap, String(describing: value0))
    case let .buildConstKeyMap(elementCount: value0):
      return EmittedInstruction(.buildConstKeyMap, String(describing: value0))
    case let .setAdd(value0):
      return EmittedInstruction(.setAdd, String(describing: value0))
    case let .listAppend(value0):
      return EmittedInstruction(.listAppend, String(describing: value0))
    case let .mapAdd(value0):
      return EmittedInstruction(.mapAdd, String(describing: value0))
    case let .buildTupleUnpack(elementCount: value0):
      return EmittedInstruction(.buildTupleUnpack, String(describing: value0))
    case let .buildTupleUnpackWithCall(elementCount: value0):
      return EmittedInstruction(.buildTupleUnpackWithCall, String(describing: value0))
    case let .buildListUnpack(elementCount: value0):
      return EmittedInstruction(.buildListUnpack, String(describing: value0))
    case let .buildSetUnpack(elementCount: value0):
      return EmittedInstruction(.buildSetUnpack, String(describing: value0))
    case let .buildMapUnpack(elementCount: value0):
      return EmittedInstruction(.buildMapUnpack, String(describing: value0))
    case let .buildMapUnpackWithCall(elementCount: value0):
      return EmittedInstruction(.buildMapUnpackWithCall, String(describing: value0))
    case let .unpackSequence(elementCount: value0):
      return EmittedInstruction(.unpackSequence, String(describing: value0))
    case let .unpackEx(elementCountBefore: value0):
      return EmittedInstruction(.unpackEx, String(describing: value0))
    case let .loadConst(index: value0):
      return EmittedInstruction(.loadConst, String(describing: value0))
    case let .storeName(nameIndex: value0):
      return EmittedInstruction(.storeName, String(describing: value0))
    case let .loadName(nameIndex: value0):
      return EmittedInstruction(.loadName, String(describing: value0))
    case let .deleteName(nameIndex: value0):
      return EmittedInstruction(.deleteName, String(describing: value0))
    case let .storeAttribute(nameIndex: value0):
      return EmittedInstruction(.storeAttribute, String(describing: value0))
    case let .loadAttribute(nameIndex: value0):
      return EmittedInstruction(.loadAttribute, String(describing: value0))
    case let .deleteAttribute(nameIndex: value0):
      return EmittedInstruction(.deleteAttribute, String(describing: value0))
    case .binarySubscript:
      return EmittedInstruction(.binarySubscript)
    case .storeSubscript:
      return EmittedInstruction(.storeSubscript)
    case .deleteSubscript:
      return EmittedInstruction(.deleteSubscript)
    case let .storeGlobal(nameIndex: value0):
      return EmittedInstruction(.storeGlobal, String(describing: value0))
    case let .loadGlobal(nameIndex: value0):
      return EmittedInstruction(.loadGlobal, String(describing: value0))
    case let .deleteGlobal(nameIndex: value0):
      return EmittedInstruction(.deleteGlobal, String(describing: value0))
    case let .loadFast(nameIndex: value0):
      return EmittedInstruction(.loadFast, String(describing: value0))
    case let .storeFast(nameIndex: value0):
      return EmittedInstruction(.storeFast, String(describing: value0))
    case let .deleteFast(nameIndex: value0):
      return EmittedInstruction(.deleteFast, String(describing: value0))
    case let .loadDeref(nameIndex: value0):
      return EmittedInstruction(.loadDeref, String(describing: value0))
    case let .storeDeref(nameIndex: value0):
      return EmittedInstruction(.storeDeref, String(describing: value0))
    case let .deleteDeref(nameIndex: value0):
      return EmittedInstruction(.deleteDeref, String(describing: value0))
    case let .loadClassDeref(nameIndex: value0):
      return EmittedInstruction(.loadClassDeref, String(describing: value0))
    case let .makeFunction(value0):
      return EmittedInstruction(.makeFunction, String(describing: value0))
    case let .callFunction(argumentCount: value0):
      return EmittedInstruction(.callFunction, String(describing: value0))
    case let .callFunctionKw(argumentCount: value0):
      return EmittedInstruction(.callFunctionKw, String(describing: value0))
    case let .callFunctionEx(hasKeywordArguments: value0):
      return EmittedInstruction(.callFunctionEx, String(describing: value0))
    case .`return`:
      return EmittedInstruction(.return)
    case .loadBuildClass:
      return EmittedInstruction(.loadBuildClass)
    case let .loadMethod(nameIndex: value0):
      return EmittedInstruction(.loadMethod, String(describing: value0))
    case let .callMethod(argumentCount: value0):
      return EmittedInstruction(.callMethod, String(describing: value0))
    case .importStar:
      return EmittedInstruction(.importStar)
    case let .importName(nameIndex: value0):
      return EmittedInstruction(.importName, String(describing: value0))
    case let .importFrom(nameIndex: value0):
      return EmittedInstruction(.importFrom, String(describing: value0))
    case .popExcept:
      return EmittedInstruction(.popExcept)
    case .endFinally:
      return EmittedInstruction(.endFinally)
    case let .setupExcept(value0):
      return EmittedInstruction(.setupExcept, String(describing: value0))
    case let .setupFinally(value0):
      return EmittedInstruction(.setupFinally, String(describing: value0))
    case let .raiseVarargs(value0):
      return EmittedInstruction(.raiseVarargs, String(describing: value0))
    case let .setupWith(value0):
      return EmittedInstruction(.setupWith, String(describing: value0))
    case .withCleanupStart:
      return EmittedInstruction(.withCleanupStart)
    case .withCleanupFinish:
      return EmittedInstruction(.withCleanupFinish)
    case .beforeAsyncWith:
      return EmittedInstruction(.beforeAsyncWith)
    case .setupAsyncWith:
      return EmittedInstruction(.setupAsyncWith)
    case let .jumpAbsolute(labelIndex: value0):
      return EmittedInstruction(.jumpAbsolute, String(describing: value0))
    case let .popJumpIfTrue(labelIndex: value0):
      return EmittedInstruction(.popJumpIfTrue, String(describing: value0))
    case let .popJumpIfFalse(labelIndex: value0):
      return EmittedInstruction(.popJumpIfFalse, String(describing: value0))
    case let .jumpIfTrueOrPop(labelIndex: value0):
      return EmittedInstruction(.jumpIfTrueOrPop, String(describing: value0))
    case let .jumpIfFalseOrPop(labelIndex: value0):
      return EmittedInstruction(.jumpIfFalseOrPop, String(describing: value0))
    case let .formatValue(conversion: conversion, hasFormat: hasFormat):
      return EmittedInstruction(.formatValue, "\(conversion) hasFormat: \(hasFormat)")
    case let .buildString(value0):
      return EmittedInstruction(.buildString, String(describing: value0))
    case let .extendedArg(value0):
      return EmittedInstruction(.extendedArg, String(describing: value0))
    case .setupAnnotations:
      return EmittedInstruction(.setupAnnotations)
    case .popBlock:
      return EmittedInstruction(.popBlock)
    case let .loadClosure(cellOrFreeIndex: value0):
      return EmittedInstruction(.loadClosure, String(describing: value0))
    case let .buildSlice(value0):
      return EmittedInstruction(.buildSlice, String(describing: value0))
    }
  }

}

