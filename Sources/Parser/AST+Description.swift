// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// This file was auto-generated by Elsa from 'ast.letitgo' using 'ast-desc' command.
// DO NOT EDIT!

import Foundation
import Core
import Lexer

// swiftlint:disable trailing_newline
// swiftlint:disable line_length

extension Expression: CustomStringConvertible {
  public var description: String {
    return "Expression(kind: \(self.kind), start: \(self.start), end: \(self.end))"
  }
}

extension ExpressionKind: CustomStringConvertible {
  public var description: String {
    switch self {
    case .true: return "true"
    case .false: return "false"
    case .none: return "none"
    case .ellipsis: return "ellipsis"
    case let .identifier(p0):
      return "identifier(\(p0))"
    case let .int(p0):
      return "int(\(p0))"
    case let .float(p0):
      return "float(\(p0))"
    case let .complex(real: real, imag: imag):
      return "complex(real: \(real)), imag: \(imag)))"
    case let .bytes(p0):
      return "bytes(\(p0))"
    case let .unaryOp(p0, right: right):
      return "unaryOp(\(p0), right: \(right)))"
    case let .binaryOp(p0, left: left, right: right):
      return "binaryOp(\(p0), left: \(left)), right: \(right)))"
    case let .boolOp(p0, left: left, right: right):
      return "boolOp(\(p0), left: \(left)), right: \(right)))"
    case let .compare(left: left, elements: elements):
      return "compare(left: \(left)), elements: \(elements)))"
    case let .tuple(elements: elements):
      return "tuple(elements: \(elements)))"
    case let .list(elements: elements):
      return "list(elements: \(elements)))"
    case let .set(elements: elements):
      return "set(elements: \(elements)))"
    case let .await(p0):
      return "await(\(p0))"
    case let .yield(p0):
      return "yield(\(p0))"
    case let .yieldFrom(p0):
      return "yieldFrom(\(p0))"
    case let .lambda(args: args, body: body):
      return "lambda(args: \(args)), body: \(body)))"
    case let .namedExpr(target: target, value: value):
      return "namedExpr(target: \(target)), value: \(value)))"
    case let .ifExpression(test: test, body: body, orElse: orElse):
      return "ifExpression(test: \(test)), body: \(body)), orElse: \(orElse)))"
    case let .starred(value: value):
      return "starred(value: \(value)))"
    }
  }
}

extension UnaryOperator: CustomStringConvertible {
  public var description: String {
    switch self {
    case .invert: return "invert"
    case .not: return "not"
    case .plus: return "plus"
    case .minus: return "minus"
    }
  }
}

extension BooleanOperator: CustomStringConvertible {
  public var description: String {
    switch self {
    case .and: return "and"
    case .or: return "or"
    }
  }
}

extension BinaryOperator: CustomStringConvertible {
  public var description: String {
    switch self {
    case .add: return "add"
    case .sub: return "sub"
    case .mul: return "mul"
    case .matMul: return "matMul"
    case .div: return "div"
    case .modulo: return "modulo"
    case .pow: return "pow"
    case .leftShift: return "leftShift"
    case .rightShift: return "rightShift"
    case .bitOr: return "bitOr"
    case .bitXor: return "bitXor"
    case .bitAnd: return "bitAnd"
    case .floorDiv: return "floorDiv"
    }
  }
}

extension ComparisonElement: CustomStringConvertible {
  public var description: String {
    return "ComparisonElement(op: \(self.op), right: \(self.right))"
  }
}

extension ComparisonOperator: CustomStringConvertible {
  public var description: String {
    switch self {
    case .equal: return "equal"
    case .notEqual: return "notEqual"
    case .less: return "less"
    case .lessEqual: return "lessEqual"
    case .greater: return "greater"
    case .greaterEqual: return "greaterEqual"
    case .is: return "is"
    case .isNot: return "isNot"
    case .in: return "in"
    case .notIn: return "notIn"
    }
  }
}

extension StringGroup: CustomStringConvertible {
  public var description: String {
    switch self {
    case let .string(p0):
      return "string(\(p0))"
    case let .formattedValue(value: value, conversion: conversion, spec: spec):
      return "formattedValue(value: \(value)), conversion: \(conversion)), spec: \(spec)))"
    case let .joinedString(p0):
      return "joinedString(\(p0))"
    }
  }
}

extension ConversionFlag: CustomStringConvertible {
  public var description: String {
    switch self {
    case .str: return "str"
    case .ascii: return "ascii"
    case .repr: return "repr"
    }
  }
}

extension Arguments: CustomStringConvertible {
  public var description: String {
    return "Arguments(args: \(self.args), defaults: \(self.defaults), vararg: \(self.vararg), kwOnlyArgs: \(self.kwOnlyArgs), kwOnlyDefaults: \(self.kwOnlyDefaults), kwarg: \(self.kwarg), start: \(self.start), end: \(self.end))"
  }
}

extension Arg: CustomStringConvertible {
  public var description: String {
    return "Arg(name: \(self.name), annotation: \(self.annotation), start: \(self.start), end: \(self.end))"
  }
}

extension Vararg: CustomStringConvertible {
  public var description: String {
    switch self {
    case .none: return "none"
    case .unnamed: return "unnamed"
    case let .named(p0):
      return "named(\(p0))"
    }
  }
}

