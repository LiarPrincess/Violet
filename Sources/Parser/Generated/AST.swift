// This file was auto-generated by Elsa from 'ast.letitgo.'
// DO NOT EDIT!

import Foundation
import BigInt
import VioletCore
import VioletLexer

// swiftlint:disable file_length
// swiftlint:disable trailing_newline
// swiftlint:disable vertical_whitespace
// swiftlint:disable vertical_whitespace_closing_braces
// cSpell:ignore kwonlyargs

// MARK: - AST

/// Top (root) node in AST.
/// Represents the whole program.
///
/// See:
/// - [Official docs](https://docs.python.org/3/reference/index.html)
/// - [greentreesnakes](https://greentreesnakes.readthedocs.io/en/latest/nodes.html)
public class AST: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.start = start
    self.end = end
  }

  public func accept<V: ASTVisitor>(
      _ visitor: V
  ) throws -> V.ASTResult {
    trap("'accept' method should be overridden in subclass")
  }

  public func accept<V: ASTVisitorWithPayload>(
      _ visitor: V,
      payload: V.ASTPayload
  ) throws -> V.ASTResult {
    trap("'accept' method should be overridden in subclass")
  }
}

// MARK: - InteractiveAST

/// Used for input in interactive mode (REPL).
///
/// `interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE`
public final class InteractiveAST: AST {

  public var statements: [Statement]

  public init(
    id: ASTNodeId,
    statements: [Statement],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.statements = statements
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: ASTVisitor>(
      _ visitor: V
  ) throws -> V.ASTResult {
    try visitor.visit(self)
  }

  override public func accept<V: ASTVisitorWithPayload>(
      _ visitor: V,
      payload: V.ASTPayload
  ) throws -> V.ASTResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ModuleAST

/// Used for all input read from non-interactive files.
///
/// For example:
/// - when parsing a complete Python program (from a file or from a string);
/// - when parsing a module;
/// - when parsing a string passed to the `exec()` function;
///
/// `file_input ::=  (NEWLINE | statement)*`
public final class ModuleAST: AST {

  public var statements: [Statement]

  public init(
    id: ASTNodeId,
    statements: [Statement],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.statements = statements
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: ASTVisitor>(
      _ visitor: V
  ) throws -> V.ASTResult {
    try visitor.visit(self)
  }

  override public func accept<V: ASTVisitorWithPayload>(
      _ visitor: V,
      payload: V.ASTPayload
  ) throws -> V.ASTResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ExpressionAST

/// Used for `eval()`.
/// It ignores leading whitespace.
/// `eval_input ::= expression_list NEWLINE*`
public final class ExpressionAST: AST {

  public var expression: Expression

  public init(
    id: ASTNodeId,
    expression: Expression,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.expression = expression
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: ASTVisitor>(
      _ visitor: V
  ) throws -> V.ASTResult {
    try visitor.visit(self)
  }

  override public func accept<V: ASTVisitorWithPayload>(
      _ visitor: V,
      payload: V.ASTPayload
  ) throws -> V.ASTResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Statement

/// Syntactic unit that expresses some action to be carried out.
///
/// See:
/// - [Simple statement](https://docs.python.org/3/reference/simple_stmts.html)
/// - [Compound statement](https://docs.python.org/3/reference/compound_stmts.html)
public class Statement: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.start = start
    self.end = end
  }

  public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    trap("'accept' method should be overridden in subclass")
  }

  public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    trap("'accept' method should be overridden in subclass")
  }
}

// MARK: - FunctionDefStmt

/// A function definition.
public final class FunctionDefStmt: Statement {

  /// `name` is a raw string of the function name.
  public var name: String
  /// `args` is a arguments node.
  public var args: Arguments
  /// `body` is the list of nodes inside the function.
  public var body: NonEmptyArray<Statement>
  /// `decorators` is the list of decorators to be applied,
  ///  stored outermost first (i.e. the first in the list will be applied last).
  public var decorators: [Expression]
  /// `returns` is the return annotation (the thing after '->').
  public var returns: Expression?

  public init(
    id: ASTNodeId,
    name: String,
    args: Arguments,
    body: NonEmptyArray<Statement>,
    decorators: [Expression],
    returns: Expression?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.name = name
    self.args = args
    self.body = body
    self.decorators = decorators
    self.returns = returns
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AsyncFunctionDefStmt

/// An async def function definition.
public final class AsyncFunctionDefStmt: Statement {

  /// `name` is a raw string of the function name.
  public var name: String
  /// `args` is a arguments node.
  public var args: Arguments
  /// `body` is the list of nodes inside the function.
  public var body: NonEmptyArray<Statement>
  /// `decorators` is the list of decorators to be applied,
  ///  stored outermost first (i.e. the first in the list will be applied last).
  public var decorators: [Expression]
  /// `returns` is the return annotation (the thing after '->').
  public var returns: Expression?

  public init(
    id: ASTNodeId,
    name: String,
    args: Arguments,
    body: NonEmptyArray<Statement>,
    decorators: [Expression],
    returns: Expression?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.name = name
    self.args = args
    self.body = body
    self.decorators = decorators
    self.returns = returns
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ClassDefStmt

/// A class definition.
public final class ClassDefStmt: Statement {

  /// `name` is a raw string for the class name
  public var name: String
  /// `bases` is a list of nodes for explicitly specified base classes.
  public var bases: [Expression]
  /// `keywords` is a list of keyword nodes, principally for ‘metaclass’.
  ///  Other keywords will be passed to the metaclass, as per PEP-3115.
  ///  `*args` and `kwargs` are each a single node, as in a function call.
  ///  `*args` will be expanded to join the list of base classes,
  ///  and `kwargs` will be passed to the metaclass.
  public var keywords: [KeywordArgument]
  /// `body` is a list of nodes representing the code within the class definition.
  public var body: NonEmptyArray<Statement>
  /// `decorators` is a list of nodes, as in `FunctionDef`.
  public var decorators: [Expression]

  public init(
    id: ASTNodeId,
    name: String,
    bases: [Expression],
    keywords: [KeywordArgument],
    body: NonEmptyArray<Statement>,
    decorators: [Expression],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.name = name
    self.bases = bases
    self.keywords = keywords
    self.body = body
    self.decorators = decorators
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ReturnStmt

/// A `return` statement.
public final class ReturnStmt: Statement {

  public var value: Expression?

  public init(
    id: ASTNodeId,
    value: Expression?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - DeleteStmt

/// Represents a `del` statement.
public final class DeleteStmt: Statement {

  /// Contains a list of nodes, such as Name, Attribute or Subscript nodes.
  public var values: NonEmptyArray<Expression>

  public init(
    id: ASTNodeId,
    values: NonEmptyArray<Expression>,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.values = values
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AssignStmt

/// An assignment.
///
/// Multiple nodes in `targets` represents assigning the same value to each.
/// Unpacking is represented by putting a Tuple or List within targets.
public final class AssignStmt: Statement {

  public var targets: NonEmptyArray<Expression>
  public var value: Expression

  public init(
    id: ASTNodeId,
    targets: NonEmptyArray<Expression>,
    value: Expression,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.targets = targets
    self.value = value
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AugAssignStmt

/// Augmented assignment, such as `a += 1`.
///
/// Target can be Name, Subscript or Attribute, but not a Tuple or List
/// (unlike the targets of `Assign`).
public final class AugAssignStmt: Statement {

  public var target: Expression
  public var op: BinaryOpExpr.Operator
  public var value: Expression

  public init(
    id: ASTNodeId,
    target: Expression,
    op: BinaryOpExpr.Operator,
    value: Expression,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.target = target
    self.op = op
    self.value = value
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AnnAssignStmt

/// An assignment with a type annotation.
public final class AnnAssignStmt: Statement {

  public var target: Expression
  public var annotation: Expression
  public var value: Expression?
  /// Indicates that `target` does not appear in between parenthesis
  /// (which excludes single element tuple) and is pure name and not expression
  /// (which excludes `tangled.rapunzel`).
  public var isSimple: Bool

  public init(
    id: ASTNodeId,
    target: Expression,
    annotation: Expression,
    value: Expression?,
    isSimple: Bool,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.target = target
    self.annotation = annotation
    self.value = value
    self.isSimple = isSimple
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ForStmt

/// A `for` loop.
public final class ForStmt: Statement {

  /// `target` holds the variable(s) the loop assigns to,
  /// as a single Name, Tuple or List node.
  public var target: Expression
  /// `iterable` holds the item to be looped over.
  public var iterable: Expression
  /// Lists of nodes to execute on each iteration.
  public var body: NonEmptyArray<Statement>
  /// Lists of nodes to execute if the loop finishes normally,
  /// rather than via a break statement.
  public var orElse: [Statement]

  public init(
    id: ASTNodeId,
    target: Expression,
    iterable: Expression,
    body: NonEmptyArray<Statement>,
    orElse: [Statement],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.target = target
    self.iterable = iterable
    self.body = body
    self.orElse = orElse
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AsyncForStmt

/// An `async for` definition.
public final class AsyncForStmt: Statement {

  /// `target` holds the variable(s) the loop assigns to,
  /// as a single Name, Tuple or List node.
  public var target: Expression
  /// `iterable` holds the item to be looped over.
  public var iterable: Expression
  /// Lists of nodes to execute on each iteration.
  public var body: NonEmptyArray<Statement>
  /// Lists of nodes to execute if the loop finishes normally,
  /// rather than via a break statement.
  public var orElse: [Statement]

  public init(
    id: ASTNodeId,
    target: Expression,
    iterable: Expression,
    body: NonEmptyArray<Statement>,
    orElse: [Statement],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.target = target
    self.iterable = iterable
    self.body = body
    self.orElse = orElse
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - WhileStmt

/// A `while` loop.
public final class WhileStmt: Statement {

  /// Holds the condition, such as a Compare node.
  public var test: Expression
  /// Lists of nodes to execute on each iteration.
  public var body: NonEmptyArray<Statement>
  /// Lists of nodes to execute if the loop finishes normally,
  /// rather than via a break statement.
  public var orElse: [Statement]

  public init(
    id: ASTNodeId,
    test: Expression,
    body: NonEmptyArray<Statement>,
    orElse: [Statement],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.test = test
    self.body = body
    self.orElse = orElse
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - IfStmt

/// An if statement.
///
/// - `elif` clauses don’t have a special representation in the AST,
/// but rather appear as extra `If` nodes within the `orElse` section
/// of the previous one.
public final class IfStmt: Statement {

  /// Holds a single node, such as a Compare node.
  public var test: Expression
  /// Lists of nodes to execute if `self.test` is `True`.
  public var body: NonEmptyArray<Statement>
  /// Lists of nodes to execute if `self.test` is `False`.
  public var orElse: [Statement]

  public init(
    id: ASTNodeId,
    test: Expression,
    body: NonEmptyArray<Statement>,
    orElse: [Statement],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.test = test
    self.body = body
    self.orElse = orElse
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - WithItem

/// A single context manager in a `with` block.
public struct WithItem: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Context manager (often a Call node).
  public var contextExpr: Expression
  /// Name, Tuple or List for the `as foo` part, or `nil` if that isn’t used.
  public var optionalVars: Expression?
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    contextExpr: Expression,
    optionalVars: Expression?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.contextExpr = contextExpr
    self.optionalVars = optionalVars
    self.start = start
    self.end = end
  }

}

// MARK: - WithStmt

/// A `with` block.
public final class WithStmt: Statement {

  /// List of `WithItem` nodes representing the context managers.
  public var items: NonEmptyArray<WithItem>
  /// Indented block inside the context.
  public var body: NonEmptyArray<Statement>

  public init(
    id: ASTNodeId,
    items: NonEmptyArray<WithItem>,
    body: NonEmptyArray<Statement>,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.items = items
    self.body = body
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AsyncWithStmt

/// An `async with` definition.
public final class AsyncWithStmt: Statement {

  /// List of `WithItem` nodes representing the context managers.
  public var items: NonEmptyArray<WithItem>
  /// Indented block inside the context.
  public var body: NonEmptyArray<Statement>

  public init(
    id: ASTNodeId,
    items: NonEmptyArray<WithItem>,
    body: NonEmptyArray<Statement>,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.items = items
    self.body = body
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ExceptHandler

/// A single except clause.
public struct ExceptHandler: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Exception type it will match,  (or `.default` for a catch-all).
  public var kind: ExceptHandler.Kind
  /// List of handler nodes.
  public var body: NonEmptyArray<Statement>
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    kind: ExceptHandler.Kind,
    body: NonEmptyArray<Statement>,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.kind = kind
    self.body = body
    self.start = start
    self.end = end
  }

}

// MARK: - Kind

extension ExceptHandler {

  public enum Kind: CustomStringConvertible {

    /// Handler with type it will match, typically an `Identifier` node.
    case typed(type: Expression, asName: String?)
    /// Catch-all handler.
    case `default`

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - RaiseStmt

/// Raising an exception.
public final class RaiseStmt: Statement {

  /// Object to be raised, normally a `Call` or `Name` or `None` for a standalone raise.
  public var exception: Expression?
  /// Optional part for `y in raise x from y`.
  public var cause: Expression?

  public init(
    id: ASTNodeId,
    exception: Expression?,
    cause: Expression?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.exception = exception
    self.cause = cause
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - TryStmt

/// `try` block.
///
/// All attributes are list of nodes to execute, except for handlers,
/// which is a list of ExceptHandler nodes.
public final class TryStmt: Statement {

  public var body: NonEmptyArray<Statement>
  public var handlers: [ExceptHandler]
  public var orElse: [Statement]
  public var finally: [Statement]

  public init(
    id: ASTNodeId,
    body: NonEmptyArray<Statement>,
    handlers: [ExceptHandler],
    orElse: [Statement],
    finally: [Statement],
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.body = body
    self.handlers = handlers
    self.orElse = orElse
    self.finally = finally
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AssertStmt

/// An assertion.
public final class AssertStmt: Statement {

  /// Holds the condition, such as a `Compare` node.
  public var test: Expression
  /// Holds the failure message, normally a `Str` node.
  public var msg: Expression?

  public init(
    id: ASTNodeId,
    test: Expression,
    msg: Expression?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.test = test
    self.msg = msg
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Alias

/// Import name with optional 'as' alias.
/// Both parameters are raw strings of the names.
/// `asName` can be `nil` if the regular name is to be used.
public struct Alias: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  public var name: String
  public var asName: String?
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    name: String,
    asName: String?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.name = name
    self.asName = asName
    self.start = start
    self.end = end
  }

}

// MARK: - ImportStmt

/// An import statement.
public final class ImportStmt: Statement {

  public var names: NonEmptyArray<Alias>

  public init(
    id: ASTNodeId,
    names: NonEmptyArray<Alias>,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.names = names
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ImportFromStmt

/// Represents `from x import y`.
public final class ImportFromStmt: Statement {

  /// Raw string of the ‘from’ name, without any leading dots
  /// or `None` for statements such as `from . import foo`.
  public var moduleName: String?
  public var names: NonEmptyArray<Alias>
  /// Integer holding the level of the relative import (0 means absolute import).
  public var level: UInt8

  public init(
    id: ASTNodeId,
    moduleName: String?,
    names: NonEmptyArray<Alias>,
    level: UInt8,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.moduleName = moduleName
    self.names = names
    self.level = level
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ImportFromStarStmt

/// Represents `from x import *`.
/// - `moduleName` is a raw string of the ‘from’ name, without any leading dots
/// or None for statements such as `from . import foo`.
/// - `level` is an integer holding the level of the relative import
/// (0 means absolute import).
public final class ImportFromStarStmt: Statement {

  public var moduleName: String?
  /// Integer holding the level of the relative import (0 means absolute import).
  public var level: UInt8

  public init(
    id: ASTNodeId,
    moduleName: String?,
    level: UInt8,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.moduleName = moduleName
    self.level = level
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - GlobalStmt

/// `global` statement.
public final class GlobalStmt: Statement {

  public var identifiers: NonEmptyArray<String>

  public init(
    id: ASTNodeId,
    identifiers: NonEmptyArray<String>,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.identifiers = identifiers
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - NonlocalStmt

/// `nonlocal` statement.
public final class NonlocalStmt: Statement {

  public var identifiers: NonEmptyArray<String>

  public init(
    id: ASTNodeId,
    identifiers: NonEmptyArray<String>,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.identifiers = identifiers
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ExprStmt

/// `Expression` statement.
public final class ExprStmt: Statement {

  public var expression: Expression

  public init(
    id: ASTNodeId,
    expression: Expression,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.expression = expression
    super.init(id: id, start: start, end: end)
  }

  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - PassStmt

/// A `pass` statement.
public final class PassStmt: Statement {



  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - BreakStmt

/// `break` statement.
public final class BreakStmt: Statement {



  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ContinueStmt

/// `continue` statement.
public final class ContinueStmt: Statement {



  override public func accept<V: StatementVisitor>(
      _ visitor: V
  ) throws -> V.StatementResult {
    try visitor.visit(self)
  }

  override public func accept<V: StatementVisitorWithPayload>(
      _ visitor: V,
      payload: V.StatementPayload
  ) throws -> V.StatementResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ExpressionContext

/// What are we going to do with this expression?
public enum ExpressionContext: CustomStringConvertible {

  case store
  case load
  case del

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }
}

// MARK: - Expression

/// Combination of one or more constants, variables, operators and functions
/// that the programming language interprets and computes to produce another value.
///
/// See: [docs](https://docs.python.org/3/reference/expressions.html)
public class Expression: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Why do we need this expression? Store? Load? Delete?
  public var context: ExpressionContext
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.context = context
    self.start = start
    self.end = end
  }

  public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    trap("'accept' method should be overridden in subclass")
  }

  public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    trap("'accept' method should be overridden in subclass")
  }
}

// MARK: - TrueExpr

public final class TrueExpr: Expression {



  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - FalseExpr

public final class FalseExpr: Expression {



  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - NoneExpr

public final class NoneExpr: Expression {



  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - EllipsisExpr

public final class EllipsisExpr: Expression {



  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Group

extension StringExpr {

  /// For normal strings and f-strings, concatenate them together.
  public enum Group: CustomStringConvertible {

    /// String - no f-strings.
    case literal(String)
    /// FormattedValue - just an f-string (with no leading or trailing literals).
    case formattedValue(Expression, conversion: StringExpr.Conversion?, spec: String?)
    /// JoinedStr - if there are multiple f-strings or any literals involved.
    case joined([Group])

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - Conversion

extension StringExpr {

  /// Transforms a value prior to formatting it.
  public enum Conversion: CustomStringConvertible {

    /// Converts by calling `str(<value>)`.
    case str
    /// Converts by calling `ascii(<value>)`.
    case ascii
    /// Converts by calling `repr(<value>)`.
    case repr

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - IdentifierExpr

public final class IdentifierExpr: Expression {

  public var value: String

  public init(
    id: ASTNodeId,
    value: String,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - StringExpr

public final class StringExpr: Expression {

  public var value: StringExpr.Group

  public init(
    id: ASTNodeId,
    value: StringExpr.Group,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - IntExpr

public final class IntExpr: Expression {

  public var value: BigInt

  public init(
    id: ASTNodeId,
    value: BigInt,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - FloatExpr

public final class FloatExpr: Expression {

  public var value: Double

  public init(
    id: ASTNodeId,
    value: Double,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ComplexExpr

public final class ComplexExpr: Expression {

  public var real: Double
  public var imag: Double

  public init(
    id: ASTNodeId,
    real: Double,
    imag: Double,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.real = real
    self.imag = imag
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - BytesExpr

public final class BytesExpr: Expression {

  public var value: Data

  public init(
    id: ASTNodeId,
    value: Data,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Operator

extension UnaryOpExpr {

  public enum Operator: CustomStringConvertible {

    /// Bitwise inversion of its integer argument.
    /// Only applies to integral numbers.
    case invert
    /// True if its argument is false, False otherwise.
    case not
    /// Unchanged argument. CPython: UAdd (unary add).
    case plus
    /// Negation of its numeric argument. CPython: USub (unary sub).
    case minus

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - UnaryOpExpr

/// Operation with single operand.
public final class UnaryOpExpr: Expression {

  public var op: UnaryOpExpr.Operator
  public var right: Expression

  public init(
    id: ASTNodeId,
    op: UnaryOpExpr.Operator,
    right: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.op = op
    self.right = right
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Operator

extension BinaryOpExpr {

  public enum Operator: CustomStringConvertible {

    /// Sum of its arguments.
    /// - Numbers added together.
    /// - Sequences are concatenated.
    case add
    /// Difference of its arguments.
    case sub
    /// Product of its arguments.
    /// - Numbers multiplied together.
    /// - For integer and sequence repetition is performed.
    case mul
    /// Intended to be used for matrix multiplication.
    /// No builtin Python types implement this operator.
    case matMul
    /// Quotient of their arguments.
    /// Division of integers yields a float.
    case div
    /// Remainder from the division of the first argument by the second.
    case modulo
    /// Left argument raised to the power of its right argument.
    case pow
    /// Shift the first argument to the left by the number of bits
    /// given by the second argument.
    case leftShift
    /// Shift the first argument to the right by the number of bits
    /// given by the second argument.
    case rightShift
    /// Bitwise (inclusive) OR of its arguments, which must be integers.
    case bitOr
    /// Bitwise XOR (exclusive OR) of its arguments, which must be integers.
    case bitXor
    /// Bitwise AND of its arguments, which must be integers.
    case bitAnd
    /// Quotient of their arguments.
    /// Floor division of integers results in an integer.
    case floorDiv

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - BinaryOpExpr

/// Operation with 2 operands.
public final class BinaryOpExpr: Expression {

  public var op: BinaryOpExpr.Operator
  public var left: Expression
  public var right: Expression

  public init(
    id: ASTNodeId,
    op: BinaryOpExpr.Operator,
    left: Expression,
    right: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.op = op
    self.left = left
    self.right = right
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Operator

extension BoolOpExpr {

  public enum Operator: CustomStringConvertible {

    /// Logical `and` with short-circuit.
    case and
    /// Logical `or` with short-circuit.
    case or

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - BoolOpExpr

/// Operation with logical values as operands.
/// Returns last evaluated argument (even if it's not strictly `True` or `False`).
/// - Note:
/// Following values are interpreted as false:
/// - False
/// - None
/// - numeric zero
/// - empty strings
/// - empty containers
public final class BoolOpExpr: Expression {

  public var op: BoolOpExpr.Operator
  public var left: Expression
  public var right: Expression

  public init(
    id: ASTNodeId,
    op: BoolOpExpr.Operator,
    left: Expression,
    right: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.op = op
    self.left = left
    self.right = right
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Operator

extension CompareExpr {

  public enum Operator: CustomStringConvertible {

    /// True when two operands are equal.
    case equal
    /// True when two operands are not equal.
    case notEqual
    /// True when left operand is less than the value of right operand.
    case less
    /// True when left operand is less than or equal to the value of right operand.
    case lessEqual
    /// True when left operand is greater than the value of right operand.
    case greater
    /// True when left operand is greater than or equal to the value of right operand.
    case greaterEqual
    /// True when x and y are the same object.
    case `is`
    /// Negation of `x is y`.
    case isNot
    /// True when x is a member of s.
    case `in`
    /// Negation of `x in s`
    case notIn

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - Element

extension CompareExpr {

  public struct Element: CustomStringConvertible {

    public var op: CompareExpr.Operator
    public var right: Expression

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }

    public init(
      op: CompareExpr.Operator,
      right: Expression
    ) {
      self.op = op
      self.right = right
    }

  }
}

// MARK: - CompareExpr

public final class CompareExpr: Expression {

  public var left: Expression
  public var elements: NonEmptyArray<CompareExpr.Element>

  public init(
    id: ASTNodeId,
    left: Expression,
    elements: NonEmptyArray<CompareExpr.Element>,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.left = left
    self.elements = elements
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Element

extension DictionaryExpr {

  public enum Element: CustomStringConvertible {

    /// `**expr`
    case unpacking(Expression)
    /// `key : value`
    case keyValue(key: Expression, value: Expression)

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - TupleExpr

/// Values separated by commas (sometimes between parentheses): (a,b).
public final class TupleExpr: Expression {

  public var elements: [Expression]

  public init(
    id: ASTNodeId,
    elements: [Expression],
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.elements = elements
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - ListExpr

/// List of comma-separated values between square brackets: [a,b].
public final class ListExpr: Expression {

  public var elements: [Expression]

  public init(
    id: ASTNodeId,
    elements: [Expression],
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.elements = elements
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - DictionaryExpr

/// Set of `key: value` pairs between braces: {a: b}. Keys are unique.
public final class DictionaryExpr: Expression {

  public var elements: [DictionaryExpr.Element]

  public init(
    id: ASTNodeId,
    elements: [DictionaryExpr.Element],
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.elements = elements
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - SetExpr

/// List of comma-separated values between braces: {a}. Unordered with no duplicates.
public final class SetExpr: Expression {

  public var elements: [Expression]

  public init(
    id: ASTNodeId,
    elements: [Expression],
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.elements = elements
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Comprehension

/// One `for` clause in a comprehension.
public struct Comprehension: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Reference to use for each element,
  /// typically a `Identifier` or `Tuple` node.
  public var target: Expression
  /// Object to iterate over.
  public var iterable: Expression
  /// List of test expressions. We can have multiple `ifs`.
  public var ifs: [Expression]
  /// Indicates that the comprehension is asynchronous.
  public var isAsync: Bool
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    target: Expression,
    iterable: Expression,
    ifs: [Expression],
    isAsync: Bool,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.target = target
    self.iterable = iterable
    self.ifs = ifs
    self.isAsync = isAsync
    self.start = start
    self.end = end
  }

}

// MARK: - ListComprehensionExpr

/// Brackets containing an expression followed by a for clause and then
/// zero or more for or if clauses.
public final class ListComprehensionExpr: Expression {

  /// Expression that will be evaluated for each item
  public var element: Expression
  public var generators: NonEmptyArray<Comprehension>

  public init(
    id: ASTNodeId,
    element: Expression,
    generators: NonEmptyArray<Comprehension>,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.element = element
    self.generators = generators
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - SetComprehensionExpr

/// Brackets containing an expression followed by a for clause and then
/// zero or more for or if clauses.
public final class SetComprehensionExpr: Expression {

  /// Expression that will be evaluated for each item
  public var element: Expression
  public var generators: NonEmptyArray<Comprehension>

  public init(
    id: ASTNodeId,
    element: Expression,
    generators: NonEmptyArray<Comprehension>,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.element = element
    self.generators = generators
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - DictionaryComprehensionExpr

/// Brackets containing an expression followed by a for clause and then
/// zero or more for or if clauses.
public final class DictionaryComprehensionExpr: Expression {

  /// Expression that will be evaluated for each item
  public var key: Expression
  /// Expression that will be evaluated for each item
  public var value: Expression
  public var generators: NonEmptyArray<Comprehension>

  public init(
    id: ASTNodeId,
    key: Expression,
    value: Expression,
    generators: NonEmptyArray<Comprehension>,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.key = key
    self.value = value
    self.generators = generators
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - GeneratorExpr

/// Expression followed by a for clause and then
/// zero or more for or if clauses.
public final class GeneratorExpr: Expression {

  /// Expression that will be evaluated for each item
  public var element: Expression
  public var generators: NonEmptyArray<Comprehension>

  public init(
    id: ASTNodeId,
    element: Expression,
    generators: NonEmptyArray<Comprehension>,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.element = element
    self.generators = generators
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AwaitExpr

/// An await expression.
/// `value` is what it waits for.
///
/// Only valid in the body of an AsyncFunctionDef.
public final class AwaitExpr: Expression {

  public var value: Expression

  public init(
    id: ASTNodeId,
    value: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - YieldExpr

/// A `yield` or `yield from` expression.
/// Because these are expressions, they must be wrapped in a `Expr` node
/// if the value sent back is not used.
public final class YieldExpr: Expression {

  public var value: Expression?

  public init(
    id: ASTNodeId,
    value: Expression?,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - YieldFromExpr

/// A `yield` or `yield from` expression.
/// Because these are expressions, they must be wrapped in a `Expr` node
/// if the value sent back is not used.
public final class YieldFromExpr: Expression {

  public var value: Expression

  public init(
    id: ASTNodeId,
    value: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.value = value
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - LambdaExpr

/// Minimal function definition that can be used inside an expression.
/// Unlike `FunctionDef`, body holds a single node.
public final class LambdaExpr: Expression {

  public var args: Arguments
  public var body: Expression

  public init(
    id: ASTNodeId,
    args: Arguments,
    body: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.args = args
    self.body = body
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - CallExpr

/// A function call.
/// - `func` - function to call
/// - `args` - arguments passed by position
/// - `keywords` - keyword objects representing arguments passed by keyword
public final class CallExpr: Expression {

  public var function: Expression
  public var args: [Expression]
  public var keywords: [KeywordArgument]

  public init(
    id: ASTNodeId,
    function: Expression,
    args: [Expression],
    keywords: [KeywordArgument],
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.function = function
    self.args = args
    self.keywords = keywords
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - AttributeExpr

/// For example `apple.juice = poison`.
public final class AttributeExpr: Expression {

  public var object: Expression
  public var name: String

  public init(
    id: ASTNodeId,
    object: Expression,
    name: String,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.object = object
    self.name = name
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Slice

public struct Slice: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  public var kind: Slice.Kind
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    kind: Slice.Kind,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.kind = kind
    self.start = start
    self.end = end
  }

}

// MARK: - Kind

extension Slice {

  public enum Kind: CustomStringConvertible {

    /// Regular slicing: `movies[pinocchio:frozen2]`.
    case slice(lower: Expression?, upper: Expression?, step: Expression?)
    /// Advanced slicing: `frozen[kristoff:ana, olaf]`.
    /// `value` holds a list of `Slice` and `Index` nodes.
    case extSlice(NonEmptyArray<Slice>)
    /// Subscripting with a single value: `frozen[elsa]`.
    case index(Expression)

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

// MARK: - SubscriptExpr

/// For example `apple[juice] = poison`.
public final class SubscriptExpr: Expression {

  public var object: Expression
  public var slice: Slice

  public init(
    id: ASTNodeId,
    object: Expression,
    slice: Slice,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.object = object
    self.slice = slice
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - IfExpr

/// For example: `1 if True else 2`
public final class IfExpr: Expression {

  public var test: Expression
  public var body: Expression
  public var orElse: Expression

  public init(
    id: ASTNodeId,
    test: Expression,
    body: Expression,
    orElse: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.test = test
    self.body = body
    self.orElse = orElse
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - StarredExpr

/// For example:
/// `dwarfs = ["Doc", "Grumpy", "Happy", "Sleepy", "Bashful", "Sneezy", "Dopey"]`
/// `singSong(*dwarfs)`
public final class StarredExpr: Expression {

  public var expression: Expression

  public init(
    id: ASTNodeId,
    expression: Expression,
    context: ExpressionContext,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.expression = expression
    super.init(id: id, context: context, start: start, end: end)
  }

  override public func accept<V: ExpressionVisitor>(
      _ visitor: V
  ) throws -> V.ExpressionResult {
    try visitor.visit(self)
  }

  override public func accept<V: ExpressionVisitorWithPayload>(
      _ visitor: V,
      payload: V.ExpressionPayload
  ) throws -> V.ExpressionResult {
    try visitor.visit(self, payload: payload)
  }
}

// MARK: - Arguments

/// The arguments for a function passed by value
/// (where the value is always an object reference, not the value of the object).
/// https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions"
public struct Arguments: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Function positional arguments.
  /// When a function is called, positional arguments are mapped
  /// to these parameters based solely on their position.
  public var args: [Argument]
  /// Count of positional-only arguments.
  public var posOnlyArgCount: Int
  /// Default values for positional arguments.
  /// If there are fewer defaults, they correspond to the last *n* arguments.
  /// - Important: The default value is evaluated only **once**.
  public var defaults: [Expression]
  /// Non-keyworded variable length arguments.
  /// By convention called `*args`.
  public var vararg: Vararg
  /// Parameters which occur after the '*args'.
  /// Can only be used as keywords rather than positional arguments.
  /// CPython `kwonlyargs`.
  public var kwOnlyArgs: [Argument]
  /// Default values for keyword-only arguments.
  /// If no default value is specified then implicit `None` is assumed.
  /// CPython `kw_defaults`.
  /// - Important: The default value is evaluated only **once**.
  public var kwOnlyDefaults: [Expression]
  /// Keyworded (named) variable length arguments.
  /// By convention called `**kwargs`.
  public var kwarg: Argument?
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    args: [Argument],
    posOnlyArgCount: Int,
    defaults: [Expression],
    vararg: Vararg,
    kwOnlyArgs: [Argument],
    kwOnlyDefaults: [Expression],
    kwarg: Argument?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.args = args
    self.posOnlyArgCount = posOnlyArgCount
    self.defaults = defaults
    self.vararg = vararg
    self.kwOnlyArgs = kwOnlyArgs
    self.kwOnlyDefaults = kwOnlyDefaults
    self.kwarg = kwarg
    self.start = start
    self.end = end
  }

}

// MARK: - Argument

public struct Argument: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Argument name.
  public var name: String
  /// Python expression evaluated at compile time.
  /// Not used during runtime, can be used by third party libraries.
  /// Introduced in PEP 3107.
  public var annotation: Expression?
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    name: String,
    annotation: Expression?,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.name = name
    self.annotation = annotation
    self.start = start
    self.end = end
  }

}

// MARK: - Vararg

public enum Vararg: CustomStringConvertible {

  case none
  /// Separator for keyword arguments. Represented by just `*`.
  case unnamed
  case named(Argument)

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }
}

// MARK: - KeywordArgument

/// A keyword argument to a function call or class definition.
/// `nil` name is used for `**kwargs`.
public struct KeywordArgument: ASTNode, CustomStringConvertible {

  /// A unique node identifier.
  /// Mostly used for efficient Equatable/Hashable implementation.
  public var id: ASTNodeId
  /// Type of the keyword argument, either dictionary unpack (`**tangled`)
  /// or named (`princess=rapunzel`).
  public var kind: KeywordArgument.Kind
  /// Node to pass in.
  public var value: Expression
  /// Location of the first character in the source code.
  public var start: SourceLocation
  /// Location just after the last character in the source code.
  public var end: SourceLocation

  public var description: String {
    let printer = ASTPrinter()
    let doc = printer.visit(self)
    return doc.layout()
  }

  public init(
    id: ASTNodeId,
    kind: KeywordArgument.Kind,
    value: Expression,
    start: SourceLocation,
    end: SourceLocation
  ) {
    self.id = id
    self.kind = kind
    self.value = value
    self.start = start
    self.end = end
  }

}

// MARK: - Kind

extension KeywordArgument {

  public enum Kind: CustomStringConvertible {

    case dictionaryUnpack
    case named(String)

    public var description: String {
      let printer = ASTPrinter()
      let doc = printer.visit(self)
      return doc.layout()
    }
  }
}

