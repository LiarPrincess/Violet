extension Instruction {

  // MARK: - Constants

  /// Each instruction is 2 bytes in size.
  public static let byteSize = 2

  /// Maximum argument for an single instruction.
  public static let maxArgument = 0xff // (the same value as UInt8.max)

  /// Maximum argument for an instruction with 1x `extendedArg` before it.
  public static let maxExtendedArgument1 = 0xffff

  /// Maximum argument for an instruction with 2x `extendedArg` before it.
  public static let maxExtendedArgument2 = 0xff_ffff

  /// Maximum argument for an instruction with 3x `extendedArg` before it.
  public static let maxExtendedArgument3 = 0xffff_ffff

  // MARK: - Function flags

  // Normally this would be generated by Elsa,
  // but Elsa does not support option sets.

  /// Function properties used in `MakeFunction` instruction.
  public struct FunctionFlags: OptionSet, Equatable {

    public let rawValue: UInt8

    /// 0x01
    public static let hasPositionalArgDefaults = FunctionFlags(rawValue: 0x01)
    /// 0x02
    public static let hasKwOnlyArgDefaults = FunctionFlags(rawValue: 0x02)
    /// 0x04
    public static let hasAnnotations = FunctionFlags(rawValue: 0x04)
    /// 0x08
    public static let hasFreeVariables = FunctionFlags(rawValue: 0x08)

    public init(rawValue: UInt8) {
      self.rawValue = rawValue
    }
  }

  // MARK: - UnpackExArg

  /// Helper for handling the `unpackEx` instruction argument.
  public struct UnpackExArg {

    public let value: Int

    public var countBefore: Int {
      return self.value & 0xff
    }

    public var countAfter: Int {
      return self.value >> 8
    }

    public init(value: Int) {
      self.value = value
    }

    public init(countBefore: Int, countAfter: Int) {
      precondition(0 <= countBefore && countBefore <= 0xff)
      precondition(0 <= countAfter && countAfter <= 0xff_ffff)
      self.value = countAfter << 8 | countBefore
    }
  }
}
