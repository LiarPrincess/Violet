# Bytecode

This module contains VM instructions.

## Important files

- `Generated/Instruction.swift` - VM instructions generated by [Elsa](https://github.com/LiarPrincess/Violet/Sources/Elsa) from [Definitions/opcodes.letitgo](https://github.com/LiarPrincess/Violet/Definitions/opcodes.letitgo). Each instruction has exactly 2 bytes (just like in CPython).

- `CodeObject` - container for `Instructions`. It will also contain some additional information like: `class` name, constants, variable names etc.

- `CodeObjectBuilder` - helper for creating new `CodeObjects` (mostly dealing with appending new instructions).

## Improvement ideas

- instruction views - we store instructions as an array of `Instruction` instances. Unfortunately some instruction arguments do not fit in a single byte, which means that a single instruction may also contain `ExtendedArg` prefix that has to be read to properly decode it (for example if we wanted to emit `BuildTuple` with argument of 270 we have to emit `ExtendedArg` with 255 as an argument and then `BuildTuple` with 15 as an argument). Currently each place that uses `CodeObject` is responsible for this, without any code sharing. The idea is to create view/overlay above `CodeObject.instructions` that solves this problem (quite similar to how we have different views for built-in `Swift.String`).

## Instruction size

As we said earlier, we are targeting 2-bytes per instruction. But what does that mean and why is it important?

### Multiple bytes per instruction

First, let's look at this type:

```Swift
enum Foo64 {
  case value(UInt64)
  case other
}
```

How would we represent it in memory?
Well… we know that we need to store `UInt64`, so that means that we need *at-least* 64 bits. We also need a way to differentiate between `Foo64.value` and `Foo64.other`, so that's another bit (let's call it `tag`).

This gives us:
- `value(UInt64)` - 64 bits for `UInt64` + 1 bit for `tag` = 65 bits
- `other` - 1 bit for `tag`, all of the other bits are unused

Which in Swift terms is:

```Swift
MemoryLayout<Foo64>.size // -> 9 bytes
MemoryLayout<Foo64>.stride // -> 16 bytes
```

Which means:
- size: 9 bytes - 65 bits rounded up to next byte. Nothing interesting, but it shows that our logic is correct.
- stride: 16 bytes - number of bytes used for a single instance when stored in an array (you know… just like we are doing inside `CodeObject`). Value of 16 means that after each instance there are 7 unused bytes (ooops…).

This type is bad for:
- memory usage - all of the instances take 9 bytes, even if they represent `Foo64.other` (which needs only a single bit)
- cache efficiency - tons of unused memory inside CPU cache, because `MemoryLayout<Foo64>.size != MemoryLayout<Foo64>.stride`

### 2-bytes per instruction

Now, let's look at the following type:

```Swift
enum Foo8 {
  case value(UInt8)
  case other
}

MemoryLayout<Foo8>.size // -> 2
MemoryLayout<Foo8>.stride // -> 2
```

This means:
- size: 2 bytes - 1 byte for tag + 1 for value
- stride: 2 bytes - `Foo8` instances are tightly packed inside the array with no space in-between.

This type uses less memory than `Foo64` and it is also more cache efficient.

The problem is that it has different semantics. `Foo64` allowed us to store the whole `UInt64`, while `Foo8` only `UInt8`! We can fix this with an additional `extendedArg` case:

```Swift
enum Foo8Extended {
  case value(UInt8)
  case other
  // Prefixes `value` when its argument is too big to fit into the `UInt8`. Ignored for `other`.
  case extendedArg(UInt8)
}

MemoryLayout<Foo8Extended>.size // -> 2
MemoryLayout<Foo8Extended>.stride // -> 2
```

Now if we want to emit `value` higher than `UInt8` we need to prefix it with one (or possibly more) `Foo8Extended.extendedArg` instances. To decode the original value we can:

```Swift
let extendedArg = UInt8(1)
let arg = UInt8(5)
let value = (UInt16(extendedArg) << 8) | UInt16(arg) // 261 (UInt16)
```

That may look very inefficient, but let's try to encode `UInt64` in both `Foo64` and `Foo8Extended`:
- `Foo64` - single `.value(UInt64)`, in total 9 bytes with stride of 16 bytes
- `Foo8Extended` - needs 7x `Foo8Extended.extendedArg` and a single `Foo8Extended.value`. In total it is 16 bytes with stride of 16 bytes

So, both of them take 16 bytes (stride is the thing that matters). We expect Violet to be memory-bound and not cpu-bound, so the small cpu overhead does not matter that much.

### Instruction set with `extendedArg`

Finally, let's look at our instruction set from the `extendedArg` angle:
- `Nop`, `PopTop`, `RotTwo`, `RotThree`, `DupTop`, `DupTopTwo` do have an argument.
- unary, binary and in-place operations (all 30 of them) also do have an argument.
- `CompareOp` needs to hold the comparison type (which is one of the 11 predefined values). This means that it will never require `extendedArg`.
- absolute jumps could hold an target instruction index (which would require a lot of `extendedArgs`, since most code object have more than 255 instructions). But they can also hold an index in auxiliary array (named `CodeObject.labels`) that holds jump targets. Most code object will contain less than 255 jumps, which means that they would not require `extendedArg`.
- collection builders (like `BuildTuple`, `BuildList`, `BuildSet`, `BuildMap`) need to store count of the elements, but then, again how often do we need to create collection with more than 255 elements?
- `load`, `store` and `delete` are interesting because they need to store the name which is a `String`. `Strings` are massive in Swift (way bigger than `UInt64`), so yet again we will create an auxiliary array just for them (named `CodeObject.names`). Alternative design would be to store the name on the stack and then call `load` without arguments. However, this implies object allocation with some additional stack operations. Since we know the name during the compilation we can avoid it.

### Trivia: Gameboy instruction set

Btw. similar trick was used in original [Gameboy](https://github.com/LiarPrincess/Swift-plays-Pokemon).

Gameboy instruction set contains more than 500 instructions. This is more than we can differentiate using a single byte. To solve this problem Nintendo used a special instruction (`0xcb`) that would instruct the cpu to decode the next instruction using *extended instruction set* which holds instructions above `0xff`.

The difference between what Violet does and what Nintendo did is that in the Violet case we modify next instruction **argument** and in Gameboy they modified the **instruction**.
