(This file was auto-generated by Elsa from `opcodes.letitgo.`
DO NOT EDIT!)

Nomenclature:
- `TOS` - top of the stack
- `TOS1` - item after `TOS`
- `TOS2` - item after after `TOS`

|Instruction|Description|
|-----------|-----------|
|nop|Do nothing code.|
|popTop|Removes the top-of-stack (`TOS`) item.|
|rotTwo|Swaps the two top-most stack items.|
|rotThree|Lifts second and third stack item one position up,<br/>moves top down to position three.|
|dupTop|Duplicates the reference on top of the stack.|
|dupTopTwo|Duplicates the two references on top of the stack,<br/>leaving them in the same order.|
|unaryPositive|Implements `TOS = +TOS`.|
|unaryNegative|Implements `TOS = -TOS`.|
|unaryNot|Implements `TOS = not TOS`.|
|unaryInvert|Implements `TOS = ~TOS`.|
|binaryPower|Implements `TOS = TOS1 ** TOS`.|
|binaryMultiply|Implements `TOS = TOS1 * TOS`.|
|binaryMatrixMultiply|Implements `TOS = TOS1 @ TOS`.|
|binaryFloorDivide|Implements `TOS = TOS1 // TOS`.|
|binaryTrueDivide|Implements `TOS = TOS1 / TOS`.|
|binaryModulo|Implements `TOS = TOS1 % TOS`.|
|binaryAdd|Implements `TOS = TOS1 + TOS`.|
|binarySubtract|Implements `TOS = TOS1 - TOS`.|
|binaryLShift|Implements `TOS = TOS1 << TOS`.|
|binaryRShift|Implements `TOS = TOS1 >> TOS`.|
|binaryAnd|Implements `TOS = TOS1 & TOS`.|
|binaryXor|Implements `TOS = TOS1 ^ TOS`.|
|binaryOr|Implements `TOS = TOS1 \| TOS`.|
|inPlacePower|Implements in-place `TOS = TOS1 ** TOS`.|
|inPlaceMultiply|Implements in-place `TOS = TOS1 * TOS`.|
|inPlaceMatrixMultiply|Implements in-place `TOS = TOS1 @ TOS`.|
|inPlaceFloorDivide|Implements in-place `TOS = TOS1 // TOS`.|
|inPlaceTrueDivide|Implements in-place `TOS = TOS1 / TOS`.|
|inPlaceModulo|Implements in-place `TOS = TOS1 % TOS`.|
|inPlaceAdd|Implements in-place `TOS = TOS1 + TOS`.|
|inPlaceSubtract|Implements in-place `TOS = TOS1 - TOS`.|
|inPlaceLShift|Implements in-place `TOS = TOS1 << TOS`.|
|inPlaceRShift|Implements in-place `TOS = TOS1 >> TOS`.|
|inPlaceAnd|Implements in-place `TOS = TOS1 & TOS`.|
|inPlaceXor|Implements in-place `TOS = TOS1 ^ TOS`.|
|inPlaceOr|Implements in-place `TOS = TOS1 \| TOS`.|
|compareOp(type: CompareType)|Performs a comparison operation specified by argument using `TOS` and `TOS1`.|
|getAwaitable|Implements `TOS = GetAwaitable(TOS)`.<br/><br/>`GetAwaitable(o)` returns:<br/>- `o` if `o` is a coroutine object<br/>- generator object with the `CoIterableCoroutine` flag<br/>- `o.Await`|
|getAIter|Implements `TOS = TOS.AIter()`.|
|getANext|Implements `Push(GetAwaitable(TOS.ANext()))`.<br/>See `GetAwaitable` for details.|
|yieldValue|Pops `TOS` and yields it from a generator.|
|yieldFrom|Pops `TOS` and delegates to it as a subiterator from a generator.|
|printExpr|Implements the expression statement for the interactive mode.<br/>`TOS` is removed from the stack and printed.<br/>In non-interactive mode, an expression statement is terminated with `PopTop`.|
|setupLoop(loopEndLabelIndex: LabelIndex)|Pushes a block for a loop onto the block stack.<br/>The block spans from the current instruction up until `loopEndLabel`.|
|forIter(ifEmptyLabelIndex: LabelIndex)|`TOS` is an iterator. Call its `Next()` method.<br/>If this `yields` a new value, push it on the stack (leaving the iterator below it).<br/>If not then `TOS` is popped, and the byte code counter is incremented by delta.|
|getIter|Implements `TOS = iter(TOS)`.|
|getYieldFromIter|If `TOS` is a generator iterator or coroutine object then it is left as is.<br/>Otherwise, implements `TOS = iter(TOS)`.|
|break|Terminates a loop due to a break statement.|
|continue(loopStartLabelIndex: LabelIndex)|Continues a loop due to a continue statement.<br/>`loopStartLabel` is the address to jump to<br/>(which should be a `ForIter` instruction).|
|buildTuple(elementCount: Count)|Creates a tuple consuming `count` items from the stack,<br/>and pushes the resulting tuple onto the stack.|
|buildList(elementCount: Count)|Creates a list consuming `count` items from the stack,<br/>and pushes the resulting list onto the stack.|
|buildSet(elementCount: Count)|Creates a set consuming `count` items from the stack,<br/>and pushes the resulting set onto the stack.|
|buildMap(elementCount: Count)|Pushes a new dictionary object onto the stack.<br/>Pops `2 * count` items so that the dictionary holds count entries:<br/>{..., `TOS3`: `TOS2`, `TOS1`: `TOS`}.|
|buildConstKeyMap(elementCount: Count)|The version of `BuildMap` specialized for constant keys.<br/>`elementCount` values are consumed from the stack.<br/>The top element on the stack contains a tuple of keys.|
|setAdd(relativeStackIndex: RelativeStackIndex)|Calls `set.add(TOS1[-i], TOS)`. Container object remains on the stack.<br/>Used to implement set comprehensions.|
|listAppend(relativeStackIndex: RelativeStackIndex)|Calls `list.append(TOS[-i], TOS)`. Container object remains on the stack.<br/>Used to implement list comprehensions.|
|mapAdd(relativeStackIndex: RelativeStackIndex)|Calls `dict.setItem(TOS1[-i], TOS, TOS1)`. Container object remains on the stack.<br/>Used to implement dict comprehensions.|
|buildTupleUnpack(elementCount: Count)|Pops `count` iterables from the stack, joins them in a single tuple,<br/>and pushes the result.<br/>Implements iterable unpacking in tuple displays `(*x, *y, *z)`.|
|buildTupleUnpackWithCall(elementCount: Count)|This is similar to `BuildTupleUnpack`, but is used for `f(*x, *y, *z)` call syntax.<br/>The stack item at position `count + 1` should be the corresponding callable `f`.|
|buildListUnpack(elementCount: Count)|This is similar to `BuildTupleUnpack`, but pushes a list instead of tuple.<br/>Implements iterable unpacking in list displays `[*x, *y, *z]`.|
|buildSetUnpack(elementCount: Count)|This is similar to `BuildTupleUnpack`, but pushes a set instead of tuple.<br/>Implements iterable unpacking in set displays `{*x, *y, *z}`.|
|buildMapUnpack(elementCount: Count)|Pops count mappings from the stack, merges them into a single dictionary,<br/>and pushes the result.<br/>Implements dictionary unpacking in dictionary displays `{**x, **y, **z}`.|
|buildMapUnpackWithCall(elementCount: Count)|This is similar to `BuildMapUnpack`, but is used for `f(**x, **y, **z)` call syntax.<br/>The stack item at position `count + 2` should be the corresponding callable `f`.|
|unpackSequence(elementCount: Count)|Unpacks `TOS` into count individual values,<br/>which are put onto the stack right-to-left.|
|unpackEx(arg: Count)|Implements assignment with a starred target.<br/><br/>Unpacks an iterable in `TOS` into individual values, where the total number<br/>of values can be smaller than the number of items in the iterable:<br/>one of the new values will be a list of all leftover items.<br/><br/>The low byte of counts is the number of values before the list value,<br/>the high byte of counts the number of values after it.<br/>The resulting values are put onto the stack right-to-left.<br/><br/>Use `Instruction.UnpackExArg struct` to handle argument.|
|loadConst(index: ConstantIndex)|Pushes constant pointed by `index` onto the stack.|
|storeName(nameIndex: NameIndex)|Implements `name = TOS`.|
|loadName(nameIndex: NameIndex)|Pushes the value associated with `name` onto the stack.|
|deleteName(nameIndex: NameIndex)|Implements `del name`.|
|storeAttribute(nameIndex: NameIndex)|Implements `TOS.name = TOS1`.|
|loadAttribute(nameIndex: NameIndex)|Implements `TOS = getAttr(TOS, name)`.|
|deleteAttribute(nameIndex: NameIndex)|Implements `del TOS.name`.|
|binarySubscript|Implements `TOS = TOS1[TOS]`.|
|storeSubscript|Implements `TOS1[TOS] = TOS2`.|
|deleteSubscript|Implements `del TOS1[TOS]`.|
|storeGlobal(nameIndex: NameIndex)|Works as `StoreName`, but stores the name as a `global`.|
|loadGlobal(nameIndex: NameIndex)|Loads the global named `name` onto the stack.|
|deleteGlobal(nameIndex: NameIndex)|Works as `DeleteName`, but deletes a `global` name.|
|loadFast(variableIndex: VariableIndex)|Used for local function variables.<br/>Pushes a reference to the local `names[nameIndex]` onto the stack.|
|storeFast(variableIndex: VariableIndex)|Used for local function variables.<br/>Stores TOS into the local `names[nameIndex]`.|
|deleteFast(variableIndex: VariableIndex)|Used for local function variables.<br/>Deletes local `names[nameIndex]`.|
|loadCell(cellIndex: CellIndex)|Loads the `cell` contained in slot `index` of the `cell` variable storage.<br/>Pushes a reference to the object the `cell` contains on the stack.|
|storeCell(cellIndex: CellIndex)|Stores `TOS` into the `cell` contained in slot `index` of the `cell` variable storage.|
|deleteCell(cellIndex: CellIndex)|Empties the `cell` contained in slot `index` of the `cell` variable storage.<br/>Used by the `del` statement.|
|loadFree(freeIndex: FreeIndex)|Loads the `cell` contained in slot `index` of the `free` variable storage.<br/>Pushes a reference to the object the `cell` contains on the stack.|
|storeFree(freeIndex: FreeIndex)|Stores `TOS` into the `cell` contained in slot `index` of the `free` variable storage.|
|deleteFree(freeIndex: FreeIndex)|Empties the `cell` contained in slot `index` of the `free` variable storage.<br/>Used by the `del` statement.|
|loadClassFree(freeIndex: FreeIndex)|Much like `LoadFree` but first checks the locals dictionary before consulting the `cell`.<br/>This is used for loading free variables in `class` bodies.|
|loadClosure(cellOrFreeIndex: CellOrFreeIndex)|Pushes a reference to the cell contained in slot `index`<br/>of the `cell` or `free` variable storage.<br/><br/>If `index < cellVars.count`: name of the variable is `cellVars[index]`.<br/>otherwise: name is `freeVars[index - cellVars.count]`.|
|makeFunction(flags: FunctionFlags)|Pushes a new function object on the stack.<br/><br/>From bottom to top, the consumed stack must consist of values<br/>if the argument carries a specified flag value<br/>- `0x01` - has tuple of default values for positional-only<br/>           and positional-or-keyword parameters in positional order<br/>- `0x02` - has dictionary of keyword-only parameters default values<br/>- `0x04` - has annotation dictionary<br/>- `0x08` - has tuple containing cells for free variables,<br/>           making a closure the code associated with the function (at `TOS1`)<br/>           the qualified name of the function (at `TOS`)|
|callFunction(argumentCount: Count)|Calls a callable object with positional arguments.<br/>`argc` indicates the number of positional arguments.<br/><br/>Stack layout (1st item means TOS):<br/>- positional arguments, with the right-most argument on top<br/>- callable object to call.<br/><br/>It will:<br/>1. pop all arguments and the callable object off the stack<br/>2. call the callable object with those arguments<br/>3. push the return value returned by the callable object<br/><br/>- Note:<br/>This opcode is used only for calls with positional arguments!|
|callFunctionKw(argumentCount: Count)|Calls a callable object with positional (if any) and keyword arguments.<br/>`argumentCount` indicates the total number of positional and keyword arguments.<br/><br/>Stack layout (1st item means `TOS`):<br/>- tuple of keyword argument names<br/>- keyword arguments in the order corresponding to the tuple<br/>- positional arguments, with the right-most parameter on top<br/>- callable object to call.<br/><br/>It will:<br/>1. pop all arguments and the callable object off the stack<br/>2. call the callable object with those arguments<br/>3. push the return value returned by the callable object.|
|callFunctionEx(hasKeywordArguments: Bool)|Calls a callable object with variable set of positional and keyword arguments.<br/><br/>Stack layout (1st item means `TOS`):<br/>- (if `hasKeywordArguments` is set) mapping object containing keyword arguments<br/>- iterable object containing positional arguments and a callable object to call<br/><br/>`BuildMapUnpackWithCall` and `BuildTupleUnpackWithCall` can be used for<br/>merging multiple mapping objects and iterables containing arguments.<br/><br/>It will:<br/>1. pop all arguments and the callable object off the stack<br/>2. mapping object and iterable object are each “unpacked” and their<br/>contents is passed in as keyword and positional arguments respectively<br/>3. call the callable object with those arguments<br/>4. push the return value returned by the callable object|
|return|Returns with `TOS` to the caller of the function.|
|loadBuildClass|Pushes `builtins.BuildClass()` onto the stack.<br/>It is later called by `CallFunction` to construct a class.|
|loadMethod(nameIndex: NameIndex)|Loads a method named `name` from `TOS` object.<br/><br/>`TOS` is popped and method and `TOS` are pushed when interpreter can call unbound method directly.<br/>`TOS` will be used as the first argument (`self`) by `CallMethod`.<br/>Otherwise, `NULL` and method is pushed (method is bound method or something else).|
|callMethod(argumentCount: Count)|Calls a method.<br/>`argc` is number of positional arguments.<br/>Keyword arguments are not supported.<br/><br/>This opcode is designed to be used with `LoadMethod`.<br/>Positional arguments are on top of the stack.<br/>Below them, two items described in `LoadMethod` on the stack.<br/>All of them are popped and return value is pushed.|
|importStar|Loads all symbols not starting with `_` directly from the module `TOS`<br/>to the local namespace.<br/><br/>The module is popped after loading all names.<br/>This opcode implements `from module import *`.|
|importName(nameIndex: NameIndex)|Imports the module `name`.<br/><br/>`TOS` and `TOS1` are popped and provide the `from-list` and `level` arguments of `Import()`.<br/>The module object is pushed onto the stack.<br/>The current namespace is not affected: for a proper import statement,<br/>a subsequent `StoreFast` instruction modifies the namespace.|
|importFrom(nameIndex: NameIndex)|Loads the attribute `name` from the module found in `TOS`.<br/><br/>The resulting object is pushed onto the stack,<br/>to be subsequently stored by a `StoreFast` instruction.|
|popExcept|Removes one block from the block stack.<br/>The popped block must be an exception handler block,<br/>as implicitly created when entering an except handler.<br/>In addition to popping extraneous values from the frame stack,<br/>the last three popped values are used to restore the exception state.|
|endFinally|Terminates a `finally` clause.<br/>The interpreter recalls whether the exception has to be re-raised,<br/>or whether the function returns, and continues with the outer-next block.|
|setupExcept(firstExceptLabelIndex: LabelIndex)|Pushes a try block from a try-except clause onto the block stack.<br/>`firstExceptLabel` points to the first except block.|
|setupFinally(finallyStartLabelIndex: LabelIndex)|Pushes a try block from a try-except clause onto the block stack.<br/>`finallyStartLabel` points to the finally block.|
|raiseVarargs(type: RaiseArg)|Raises an exception using one of the 3 forms of the raise statement,<br/>depending on the value of argc:<br/>- 0: raise (re-raise previous exception)<br/>- 1: raise `TOS` (raise exception instance or type at `TOS`)<br/>- 2: raise `TOS1` from `TOS` (raise exception instance or type at `TOS1` with `Cause` set to `TOS`)|
|setupWith(afterBodyLabelIndex: LabelIndex)|This opcode performs several operations before a `with` block starts.<br/><br/>It does following operations:<br/>1.loads `Exit()` from the context manager and pushes it onto the stack<br/>for later use by `WithCleanup`.<br/>2. calls `Enter()`<br/>3. block staring at to `afterBodyLabel` is pushed.<br/>4. the result of calling the enter method is pushed onto the stack.<br/><br/>The next opcode will either ignore it (`PopTop`),<br/>or store it in variable (`StoreFast`, `StoreName`, or `UnpackSequence`).|
|withCleanupStart|Cleans up the stack when a `with` statement block exits.<br/><br/>`TOS` is the context manager’s `__exit__()` bound method.<br/>Below `TOS` are 1–3 values indicating how/why the finally clause was entered:<br/>- `SECOND = None`<br/>- `(SECOND, THIRD) = (WHY_{RETURN,CONTINUE}), return value`<br/>- `SECOND = WHY_*; no return value below it`<br/>- `(SECOND, THIRD, FOURTH) = exc_info()`<br/>In the last case, `TOS(SECOND, THIRD, FOURTH)` is called,<br/>otherwise `TOS(None, None, None)`.<br/>Pushes `SECOND` and result of the call to the stack.|
|withCleanupFinish|Pops exception type and result of `exit` function call from the stack.<br/><br/>If the stack represents an exception, and the function call returns a `true` value,<br/>this information is “zapped” and replaced with a single `WhySilenced`<br/>to prevent `EndFinally` from re-raising the exception.<br/>(But non-local `goto` will still be resumed.)|
|beforeAsyncWith|Resolves `AEnter` and `AExit` from the object on top of the stack.<br/>Pushes `AExit` and result of `AEnter()` to the stack.|
|setupAsyncWith|Creates a new frame object.|
|jumpAbsolute(labelIndex: LabelIndex)|Set bytecode counter to target.|
|popJumpIfTrue(labelIndex: LabelIndex)|If `TOS` is `true`, sets the bytecode counter to target. `TOS` is popped.|
|popJumpIfFalse(labelIndex: LabelIndex)|If `TOS` is `false`, sets the bytecode counter to target. `TOS` is popped.|
|jumpIfTrueOrPop(labelIndex: LabelIndex)|If `TOS` is `true`, sets the bytecode counter to target and leaves `TOS` on the stack.<br/>Otherwise (`TOS` is false), `TOS` is popped.|
|jumpIfFalseOrPop(labelIndex: LabelIndex)|If `TOS` is `false`, sets the bytecode counter to target and leaves `TOS` on the stack.<br/>Otherwise (`TOS` is `true`), `TOS` is popped.|
|formatValue(conversion: StringConversion, hasFormat: Bool)|Used for implementing formatted literal strings (f-strings).<br/><br/>(And yes, Swift will pack both payloads in single byte).|
|buildString(elementCount: Count)|Concatenates `count` strings from the stack<br/>and pushes the resulting string onto the stack.|
|extendedArg(UInt8)|Prefixes any opcode which has an argument too big to fit into the default one `byte`.<br/><br/>`arg` holds an additional `byte` which act as higher bits in the argument.<br/>For each opcode, at most three prefixal `ExtendedArg` are allowed,<br/>forming an argument from two-byte to four-byte.|
|setupAnnotations|Checks whether Annotations is defined in `locals()`,<br/>if not it is set up to an empty `dict`.<br/><br/>This opcode is only emitted if a `class` or `module` body contains variable<br/>annotations statically.|
|popBlock|Removes one block from the block stack.<br/>Per frame, there is a stack of blocks, denoting nested loops, `try` statements, and such.|
|buildSlice(type: SliceArg)|Pushes a slice object on the stack.|
