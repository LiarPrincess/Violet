import VioletCore
import VioletBytecode
import VioletObjects

// swiftlint:disable function_parameter_count
// ^^^ Well… yep… we will need this one

extension PyFrame {
  fileprivate static func ===(lhs: PyFrame?, rhs: PyFrame) -> Bool {
    guard let lhs = lhs else {
      return false
    }

    return lhs.ptr === rhs.ptr
  }
}

extension VM {

  /// Run given code object using specified environment.
  ///
  /// CPython:
  /// PyObject *
  /// PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)
  public func eval(code: PyCode, globals: PyDict, locals: PyDict) -> PyResult {
    return self.eval(name: nil,
                     qualname: nil,
                     code: code,
                     args: [],
                     kwargs: nil,
                     defaults: [],
                     kwDefaults: nil,
                     globals: globals,
                     locals: locals,
                     closure: nil)
  }

  /// Run given code object using specified environment.
  ///
  /// Required by `PyDelegate`.
  ///
  /// CPython:
  /// PyObject *
  /// _PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals…)
  public func eval(name: PyString?,
                   qualname: PyString?,
                   code: PyCode,
                   args: [PyObject],
                   kwargs: PyDict?,
                   defaults: [PyObject],
                   kwDefaults: PyDict?,
                   globals: PyDict,
                   locals: PyDict,
                   closure: PyTuple?) -> PyResult {
    if let e = self.checkRecursionLimit() {
      return .error(e)
    }

    // We don't support zombie frames, we always create new one.
    let frame: PyFrame
    let parent = self.frames.last
    switch self.py.newFrame(parent: parent,
                            code: code,
                            args: args,
                            kwargs: kwargs,
                            defaults: defaults,
                            kwDefaults: kwDefaults,
                            locals: locals,
                            globals: globals,
                            closure: closure) {
    case let .value(f): frame = f
    case let .error(e): return .error(e)
    }

    // TODO: Everything below following line in CPython:
    /* Handle generator/coroutine/asynchronous generator */

    Debug.frameStart(self.py, frame)

    self.frames.push(frame)
    let result = Eval(vm: self, frame: frame).run()
    let popFrame = self.frames.popLast()
    assert(popFrame === frame)

    Debug.frameEnd(self.py, frame)

    return result
  }

  private func checkRecursionLimit() -> PyBaseException? {
    // 'sys.recursionLimit' is not only for recursion!
    // It also applies to non-recursive calls.
    // In this sense it is more like 'max call stack depth'.
    //
    // Try to run program generated by following code:
    //
    // fn_count = 1000
    //
    // for i in range(0, fn_count + 1):
    //   body = 'pass' if i == 0 else f'f{i-1}()'
    //   print(f'def f{i}(): {body}')
    //
    // print(f'f{fn_count}()')

    let recursionLimit = self.py.sys.recursionLimit
    let depth = self.frames.count
    let depthPlusNewFrame = depth + 1

    if depthPlusNewFrame > recursionLimit.value {
      let error = self.py.newRecursionError()
      return error.asBaseException
    }

    return nil
  }
}
