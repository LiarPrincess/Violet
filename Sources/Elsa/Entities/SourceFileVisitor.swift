import Foundation

class SourceFileVisitor {

  let sourceFile: SourceFile
  private let outputFile: URL

  var filename: String {
    self.sourceFile.url.lastPathComponent
  }

  init(sourceFile: SourceFile, outputFile: URL) {
    self.sourceFile = sourceFile
    self.outputFile = outputFile
  }

  // MARK: - Walk

  func walk() {
    self.withRedirectedStandardOutput(to: self.outputFile) {
      let warning = self.createDoNotEditWarning()
      print(warning)
      self.printFileContent()
    }
  }

  func printFileContent() {
    self.printHeader()

    for def in self.sourceFile.definitions {
      switch def {
      case let .alias(def): self.printAlias(def)
      case let .enum(def): self.printEnum(def)
      case let .indirectEnum(def): self.printIndirectEnum(def)
      case let .struct(def): self.printStruct(def)
      case let .class(def): self.printClass(def)
      case let .finalClass(def): self.printFinalClass(def)
      }
    }

    self.printFooter()
  }

  private func withRedirectedStandardOutput(to file: URL, block: () -> Void) {
    freopen(file.path, "w", stdout)
    block()
    fclose(stdout)
  }

  /// Warning at the top of the file
  func createDoNotEditWarning() -> String {
    return """
    // This file was auto-generated by Elsa from '\(self.filename).'
    // DO NOT EDIT!

    """
  }

  func printHeader() {}
  func printAlias(_ def: SourceFile.Alias) {}
  func printEnum(_ def: Enumeration) {}
  func printIndirectEnum(_ def: Enumeration) {}
  func printStruct(_ def: ProductType) {}
  func printClass(_ def: ProductType) {}
  func printFinalClass(_ def: ProductType) {}
  func printFooter() {}

  // MARK: - Print enum

  /// Print: `public enum Elsa: CustomStringConvertible {`
  func printTypeStart(_ def: Enumeration, isIndirect: Bool, indent: String) {
    let indirect = isIndirect ? "indirect " : ""
    let name = def.name.afterResolvingAlias
    let bases = def.bases.joinWithColonSpaceBefore()
    print("\(indent)public \(indirect)enum \(name)\(bases) {")
  }

  /// For each case print: `case elsa(power: Magic) {`
  func printCases(_ def: Enumeration, indent: String) {
    for caseDef in def.cases {
      self.printDoc(caseDef.doc, indent: indent + "  ")

      var properties = ""
      if !caseDef.properties.isEmpty {
        properties += "("
        properties += caseDef.properties
          .map { $0.formatForDefinition() }
          .joined(separator: ", ")
        properties += ")"
      }

      let name = caseDef.escapedName
      print("  \(indent)case \(name)\(properties)")
    }
  }

  // MARK: - Print product

  enum ProductKind: String {
    case `struct` = "struct"
    case `class` = "class"
    case finalClass = "final class"
  }

  /// Print: `public class Elsa: CustomStringConvertible {`
  func printTypeStart(_ def: ProductType, kind: ProductKind, indent: String) {
    let keyword = kind.rawValue
    let name = def.name.afterResolvingAlias
    let bases = def.bases.joinWithColonSpaceBefore()
    print("\(indent)public \(keyword) \(name)\(bases) {")
  }

  /// For each property print: `public var elsa: Princess`
  func printProperties(_ def: ProductType, indent: String) {
    if def.properties.isEmpty {
      return
    }

    for propertyDef in def.properties {
      self.printDoc(propertyDef.doc, indent: indent + "  ")
      print("  \(indent)public var \(propertyDef.nameColonType)")
    }
  }

  /// Print:
  /// ```
  /// public init(<properties>) {
  ///   self.<property> = <property>
  ///   super.init(<super-properties>)
  /// }
  /// ```
  ///
  /// You can change to property order by overriding `func sortInitProperties`.
  func printInit(_ def: ProductType, indent: String) {
    let initProperties = self.getInitProperties(def)

    // Can we use parent 'init'?
    if initProperties.onSelf.isEmpty {
      return
    }

    print("  \(indent)public init(")
    for property in initProperties.all {
      let comma = property.isLast ? "" : ","
      print("    \(indent)\(property.nameColonType)\(comma)")
    }
    print("  \(indent)) {")

    for property in initProperties.onSelf {
      print("    \(indent)self.\(property.name) = \(property.name)")
    }

    if !initProperties.onSuperclasses.isEmpty {
      print("    \(indent)super.init(", terminator: "")
      for property in initProperties.onSuperclasses {
        let comma = property.isLast ? "" : ", "
        print("\(property.name): \(property.name)\(comma)", terminator: "")
      }
      print(")")
    }

    print("  \(indent)}")
  }

  struct InitProperties {
    let onSuperclasses: [Property]
    let onSelf: [Property]
    let all: [Property]

    // swiftlint:disable:next nesting
    struct Property {
      let name: String
      let type: String
      let nameColonType: String
      var isLast: Bool

      fileprivate init(property: ProductType.Property, isLast: Bool) {
        self.name = property.name
        self.type = property.type.value
        self.nameColonType = property.nameColonType
        self.isLast = isLast
      }
    }
  }

  func getInitProperties(_ def: ProductType) -> InitProperties {
    let superclasses = self.collectSuperclasses(of: def)
    let onSuperclasses = superclasses.reversed().flatMap { $0.properties }

    let onSelf = def.properties
    let all = onSuperclasses + onSelf

    return InitProperties(
      onSuperclasses: self.sortInitProperties(self.toInitProperties(onSuperclasses)),
      onSelf: self.sortInitProperties(self.toInitProperties(onSelf)),
      all: self.sortInitProperties(self.toInitProperties(all))
    )
  }

  private func toInitProperties(
    _ properties: [ProductType.Property]
  ) -> [InitProperties.Property] {
    var result = [InitProperties.Property]()

    for property in properties {
      result.append(InitProperties.Property(property: property, isLast: false))
    }

    if !result.isEmpty {
      let lastIndex = result.count - 1
      result[lastIndex].isLast = true
    }

    return result
  }

  func sortInitProperties(
    _ properties: [InitProperties.Property]
  ) -> [InitProperties.Property] {
    // No sorting
    return properties
  }

  // MARK: - Enclosing type extension

  struct EnclosingTypeExtension {
    let indent: String
    let name: String?
    var isNested: Bool { self.name != nil }
  }

  func getEnclosingTypeExtension(_ type: Type?) -> EnclosingTypeExtension {
    guard let type = type else {
      return EnclosingTypeExtension(indent: "", name: nil)
    }

    let name = type.afterResolvingAlias
    return EnclosingTypeExtension(indent: "  ", name: name)
  }

  func printExtensionStart(_ enclosingType: EnclosingTypeExtension) {
    guard let typeName = enclosingType.name else {
      return
    }

    print("extension \(typeName) {")
    print()
  }

  func printTypeEnd(_ enclosingType: EnclosingTypeExtension) {
    if enclosingType.isNested {
      print(enclosingType.indent + "}")
    }

    print("}")
  }

  // MARK: - Print doc

  func printDoc(_ doc: Doc?, indent: String) {
    guard let doc = doc else {
      return
    }

    let string = doc.formatForPrintingInSwift(indent: indent)
    print(string)
  }

  // MARK: - Superclass/Subclass

  func collectSuperclasses(of type: ProductType) -> [ProductType] {
    var result = [ProductType]()

    var currentBase = self.getSuperclass(of: type)
    while let base = currentBase {
      result.append(base)
      currentBase = self.getSuperclass(of: base)
    }

    return result
  }

  func getSuperclass(of type: ProductType) -> ProductType? {
    guard let baseTypeName = type.bases.first else {
      return nil
    }

    for def in self.sourceFile.definitions {
      switch def {
      case let .class(c),
           let .finalClass(c):
        if c.name == baseTypeName {
          return c
        }
      case .alias,
           .enum,
           .indirectEnum,
           .struct:
        break
      }
    }

    return nil
  }

  func getSubclasses(of type: ProductType) -> [ProductType] {
    let typeName = type.name
    var result = [ProductType]()

    for def in self.sourceFile.definitions {
      switch def {
      case let .class(c),
           let .finalClass(c):
        if c.bases.contains(type: typeName) {
          result.append(c)
        }
      case .alias,
           .enum,
           .indirectEnum,
           .struct:
        break
      }
    }

    return result
  }
}
