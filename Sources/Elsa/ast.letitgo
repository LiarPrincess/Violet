@alias int = PyInt
@alias identifier = String
@alias string     = String
@alias object   = Any
@alias constant = Any

 -- less typing (also CPython used those and we are lazy)
@alias expr = Expression
@alias exprKind = ExpressionKind
@alias stmt = Statement
@alias loc = SourceLocation

--enum top =
--  Module(stmt* body, type_ignore *type_ignores)
--  | Interactive(stmt* body)
--  | Expression(expr body)
--  | FunctionType(expr* argtypes, expr returns)

--enum stmt =
--    FunctionDef     (identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)
--  | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)
--  | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)
--  | Return(expr? value)
--
--  | Delete(expr* targets)
--  | Assign(expr* targets, expr value, string? type_comment)
--  | AugAssign(expr target, operator op, expr value)
--  -- 'simple' indicates that we annotate simple name without parens
--  | AnnAssign(expr target, expr annotation, expr? value, int simple)
--
--  -- use 'orelse' because else is a keyword in target languages
--  | For     (expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
--  | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
--  | While(expr test, stmt* body, stmt* orelse)
--  | If(expr test, stmt* body, stmt* orelse)
--  | With     (withitem* items, stmt* body, string? type_comment)
--  | AsyncWith(withitem* items, stmt* body, string? type_comment)
--
--  | Raise(expr? exc, expr? cause)
--  | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
--  | Assert(expr test, expr? msg)
--
--  | Import(alias* names)
--  | ImportFrom(identifier? module, alias* names, int? level)
--
--  | Global(identifier* names)
--  | Nonlocal(identifier* names)
--  | Expr(expr value)
--  | Pass | Break | Continue

--  -- XXX Jython will be different
--  -- col_offset is the byte offset in the utf8 string the parser uses
--  attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

@doc "https://docs.python.org/3/reference/expressions.html"
@struct expr = (
  exprKind kind @doc "Type of the expression.",
  loc start @doc "Start location in the source code.",
  loc end @doc "End location in the source code."
)

@doc "https://docs.python.org/3/reference/expressions.html"
@indirect exprKind =
-- Base
    True
  | False
  | None
  | Ellipsis
-- Literals
  | Identifier(String)
  | String(StringGroup)
  | Int(PyInt)
  | Float(Double)
  | Complex(Double real, Double imag)
  | Bytes(Data)
-- Operators
  | UnaryOp(UnaryOperator, expr right) @doc "Operation with single operand."
  | BinaryOp(BinaryOperator, expr left, expr right) @doc "Operation with 2 operands."
  | BoolOp(BooleanOperator, expr left, expr right) @doc "Operation with logical values as operands.
Returns last evaluated argument (even if it's not True or False).
- Note:\nFollowing values are interpreted as false:\n- False\n- None\n- numeric zero\n- empty strings\n- empty containers"
  -- need sequence to distinguish between: x < 4 < 3 and (x < 4) < 3
  | Compare(expr left, ComparisonElement* elements)
-- Collections
  | Tuple(expr* elements) @doc "Values separated by commas (sometimes between parentheses): (a,b)."
  | List(expr* elements) @doc "List of comma-separated values between square brackets: [a,b]."
  --  | Dictionary(expr* keys, expr* values) @doc "Set of `key: value` pairs between braces: {a: b}. Keys are unique."
  | Set(expr* elements) @doc "List of comma-separated values between braces: {a}. Unordered with no duplicates."
-- Comprehensions
  --  | ListComprehension(expr elt, comprehension* generators)
  --  | SetComprehension(expr elt, comprehension* generators)
  --  | DictionaryComprehension(expr key, expr value, comprehension* generators)
-- Generators/coroutines
  -- the grammar constrains where yield expressions can occur
  --  | GeneratorExp(expr elt, comprehension* generators)
  | Await(expr)
  | Yield(expr?)
  | YieldFrom(expr)
-- Functions
  | Lambda(arguments args, expr body)
  --  | Call(expr func, expr* args, keyword* keywords)
-- Other
  | NamedExpr(expr target, expr value)
  -- 1 if True else 2 TODO: @doc
  | IfExpression(expr test, expr body, expr orelse)
  --  | Constant(constant value, string? kind)
  -- the following expression can appear in assignment context
  --  | Attribute(identifier name, expr value) -- , expr_context ctx
  --  | Subscript(expr value, slice slice) -- , expr_context ctx
  | Starred(expr value)

@enum UnaryOperator =
  Invert  @doc "Bitwise inversion of its integer argument.\nOnly applies to integral numbers."
  | Not   @doc "True if its argument is false, False otherwise."
  | Plus  @doc "Unchanged argument."
  | Minus @doc "Negation of its numeric argument."

@enum BooleanOperator =
    And @doc "Logical `and` with short-circuit."
  | Or  @doc "Logical `or` with short-circuit."

@enum BinaryOperator =
  Add      @doc "Sum of its arguments.\n- Numbers added together.\n- Sequences are concatenated."
  | Sub    @doc "Difference of its arguments."
  | Mul    @doc "Product of its arguments.\n- Numbers multiplied together.\n- For integer and sequence repetition is performed."
  | MatMul @doc "Intended to be used for matrix multiplication.\nNo builtin Python types implement this operator."
  | Div    @doc "Quotient of their arguments.\nDivision of integers yields a float."
  | Modulo @doc "Remainder from the division of the first argument by the second."
  | Pow    @doc "Left argument raised to the power of its right argument."
  | LeftShift  @doc "Shift the first argument to the left by the number of bits\ngiven by the second argument."
  | RightShift @doc "Shift the first argument to the right by the number of bits\ngiven by the second argument."
  | BitOr      @doc "Bitwise (inclusive) OR of its arguments, which must be integers."
  | BitXor     @doc "Bitwise XOR (exclusive OR) of its arguments, which must be integers."
  | BitAnd     @doc "Bitwise AND of its arguments, which must be integers."
  | FloorDiv   @doc "Quotient of their arguments.\nFloor division of integers results in an integer."

@struct ComparisonElement = (
  ComparisonOperator op,
  expr right
)

@enum ComparisonOperator =
  Equal      @doc "Equality comparison."
  | NotEqual @doc "Non equality comparison."
  | Less         @doc "Order comparison."
  | LessEqual    @doc "Order comparison."
  | Greater      @doc "Order comparison."
  | GreaterEqual @doc "Order comparison."
  | Is    @doc "`x is y` is true if and only if x and y are the same object."
  | IsNot @doc "`x is not y` returns the negation of `x is y`."
  | In    @doc "`x in s` evaluates to True if x is a member of s, and False otherwise."
  | NotIn @doc "`x not in s` returns the negation of `x in s`"

-- Based on RustPython.
-- CPython uses 'JoinedStr(expr* values)', but we know that values are strings.
@enum StringGroup =
    String(String)
  | FormattedValue(expr value, ConversionFlag? conversion, String spec) -- FormattedValue(expr value, int? conversion, expr? format_spec)
  | JoinedString(StringGroup*) -- JoinedStr(expr* values)

@doc "Transforms a value prior to formatting it."
@enum ConversionFlag =
    Str   @doc "Converts by calling `str(<value>)`."
  | Ascii @doc "Converts by calling `ascii(<value>)`."
  | Repr  @doc "Converts by calling `repr(<value>)`."

-- @enum slice = Slice(expr? lower, expr? upper, expr? step)
--  | ExtSlice(slice* dims)
--  | Index(expr value)

-- comprehension = (expr target, expr iter, expr* ifs, int is_async)

-- excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
-- attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

@doc "The arguments for a function."
@struct arguments = (
  arg* args @doc "Function positional arguments.",
  expr* defaults @doc "Default values for positional arguments.
If there are fewer defaults, they correspond to the last n arguments.
- Important: The default value is evaluated only **once**.",

  vararg vararg @doc "Non-keyworded variable length arguments.
By convention called `*args`.",
  arg* kwOnlyArgs @doc "Parameters which occur after the '*args'.
They can only be used as keywords rather than positional arguments.
CPython `kwonlyargs`.",
  expr* kwOnlyDefaults @doc "Default values for keyword-only arguments.
If there are fewer defaults, they correspond to the last n arguments.
- Important: The default value is evaluated only **once**.
CPython `kw_defaults`",

  vararg kwarg @doc "Keyworded (named) variable length arguments.
By convention called `**kwargs`.",
)

@struct arg = (
  identifier name @doc "Argument name.",
  expr? annotation @doc "Python expression evaluated at compile time.
Not used during runtime, can be used by third party libraries. (PEP 3107)",
  loc start @doc "Start location in the source code.",
  loc end @doc "End location in the source code."
) -- , string? type_comment

@enum vararg =
  none
  | anonymous
  | named(Arg)

-- attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

-- keyword arguments supplied to call (NULL identifier for **kwargs)
-- @struct keyword = (identifier? name, expr value)

-- -- import name with optional 'as' alias.
-- alias = (identifier name, identifier? asname)
--
-- withitem = (expr context_expr, expr? optional_vars)
--
-- type_ignore = TypeIgnore(int lineno, string tag)
