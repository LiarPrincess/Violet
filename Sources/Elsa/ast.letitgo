@alias int = PyInt
@alias identifier = String
@alias string     = String
@alias object   = Any
@alias constant = Any

{- less typing (also CPython used those and we are lazy) -}
@alias expr = Expression
@alias exprKind = ExpressionKind
@alias stmt = Statement
@alias stmtKind = StatementKind
@alias loc = SourceLocation

{-
This is nice source of documentation:
https://greentreesnakes.readthedocs.io/en/latest/nodes.html
-}

{-
  mod = Module(stmt* body)
      | Interactive(stmt* body)
      | Expression(expr body)
-}

{-
@struct stmt = (
  stmtKind kind @doc "Type of the statement.",
  loc start @doc "Location of the first character in the source code.",
  loc end @doc "Location just after the last character in the source code."
)

@enum stmtKind =
   FunctionDef     (identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns)
 | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns)
 | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)
 | Return(expr? value)

 | Delete(expr* targets)
 | Assign(expr* targets, expr value)
 | AugAssign(expr target, operator op, expr value)
 -- 'simple' indicates that we annotate simple name without parens
 | AnnAssign(expr target, expr annotation, expr? value, int simple)

 -- use 'orelse' because else is a keyword in target languages
 | For     (expr target, expr iter, stmt* body, stmt* orelse)
 | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse)
 | While(expr test, stmt* body, stmt* orelse)
 | If(expr test, stmt* body, stmt* orelse)
 | With     (withitem* items, stmt* body)
 | AsyncWith(withitem* items, stmt* body)

 | Raise(expr? exc, expr? cause)
 | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
 | Assert(expr test, expr? msg)

 | Import(alias* names)
 | ImportFrom(identifier? module, alias* names, int? level)

 | Global(identifier* names)
 | Nonlocal(identifier* names)
 | Expr(expr value)
 | Pass | Break | Continue

 -- XXX Jython will be different
 -- col_offset is the byte offset in the utf8 string the parser uses
 attributes (int lineno, int col_offset)
 -}

-- https://docs.python.org/3/reference/expressions.html
@struct expr = (
  -- Type of the expression.
  exprKind kind,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

-- https://docs.python.org/3/reference/expressions.html
@indirect exprKind =
{- Base -}
  True
  | False
  | None
  | Ellipsis
{- Literals -}
  | Identifier(String)
{-   | String(StringGroup) -}
  | Int(PyInt)
  | Float(Double)
  | Complex(Double real, Double imag)
  | Bytes(Data)
{- Operators -}
  -- Operation with single operand.
  | UnaryOp(UnaryOperator, expr right)
  -- Operation with 2 operands.
  | BinaryOp(BinaryOperator, expr left, expr right)
  -- Operation with logical values as operands.
  -- Returns last evaluated argument (even if it's not strictly `True` or `False`).
  -- - Note:
  -- Following values are interpreted as false:
  -- - False\n- None\n- numeric zero\n- empty strings\n- empty containers
  | BoolOp(BooleanOperator, expr left, expr right)
  {- need sequence to distinguish between: x < 4 < 3 and (x < 4) < 3 -}
  | Compare(expr left, ComparisonElement* elements)
{- Collections -}
  -- Values separated by commas (sometimes between parentheses): (a,b).
  | Tuple(expr*)
  -- List of comma-separated values between square brackets: [a,b].
  | List(expr*)
  -- Set of `key: value` pairs between braces: {a: b}. Keys are unique.
  {- | Dictionary(expr* keys, expr* values) -}
  -- List of comma-separated values between braces: {a}. Unordered with no duplicates.
  | Set(expr*)
{- Comprehensions -}
  -- Brackets containing an expression followed by a for clause and then
  -- zero or more for or if clauses.
  -- `elt` - expression that will be evaluated for each item
  | ListComprehension(expr elt, comprehension* generators)
  -- Brackets containing an expression followed by a for clause and then
  -- zero or more for or if clauses.
  -- `elt` - expression that will be evaluated for each item
  | SetComprehension(expr elt, comprehension* generators)
  -- Brackets containing an expression followed by a for clause and then
  -- zero or more for or if clauses.
  -- `key` and `value` - expressions that will be evaluated for each item
  | DictionaryComprehension(expr key, expr value, comprehension* generators)
  {- the grammar constrains where yield expressions can occur -}
  {- | GeneratorExp(expr elt, comprehension* generators) -}
{- Generators/coroutines -}
  | Await(expr)
  | Yield(expr?)
  | YieldFrom(expr)
{- Functions -}
  | Lambda(arguments args, expr body)
  {- | Call(expr func, expr* args, keyword* keywords) -}
{- Other -}
  | NamedExpr(expr target, expr value)
  {- 1 if True else 2 TODO: @doc -}
  | IfExpression(expr test, expr body, expr orElse)
  {- the following expression can appear in assignment context -}
  | Attribute(expr, identifier name)
  | Subscript(expr, slice slice)
  | Starred(expr)

@enum UnaryOperator =
  -- Bitwise inversion of its integer argument.
  -- Only applies to integral numbers.
  Invert
  -- True if its argument is false, False otherwise.
  | Not
  -- Unchanged argument. CPython: UAdd (unary add).
  | Plus
  -- Negation of its numeric argument. CPython: USub (unary sub).
  | Minus

@enum BooleanOperator =
  -- Logical `and` with short-circuit.
  And
  -- Logical `or` with short-circuit.
  | Or

@enum BinaryOperator =
  -- Sum of its arguments.
  -- - Numbers added together.
  -- - Sequences are concatenated.
  Add
  -- Difference of its arguments.
  | Sub
  -- Product of its arguments.
  -- - Numbers multiplied together.
  -- - For integer and sequence repetition is performed.
  | Mul
  -- Intended to be used for matrix multiplication.
  -- No builtin Python types implement this operator.
  | MatMul
  -- Quotient of their arguments.
  -- Division of integers yields a float.
  | Div
  -- Remainder from the division of the first argument by the second.
  | Modulo
  -- Left argument raised to the power of its right argument.
  | Pow
  -- Shift the first argument to the left by the number of bits
  -- given by the second argument.
  | LeftShift
  -- Shift the first argument to the right by the number of bits
  -- given by the second argument.
  | RightShift
  -- Bitwise (inclusive) OR of its arguments, which must be integers.
  | BitOr
  -- Bitwise XOR (exclusive OR) of its arguments, which must be integers.
  | BitXor
  -- Bitwise AND of its arguments, which must be integers.
  | BitAnd
  -- Quotient of their arguments.
  -- Floor division of integers results in an integer.
  | FloorDiv

@struct ComparisonElement = (
  ComparisonOperator op,
  expr right
)

@enum ComparisonOperator =
  -- True when two operands are equal.
  Equal
  -- True when two operands are not equal.
  | NotEqual
  -- True when left operand is less than the value of right operand.
  | Less
  -- True when left operand is less than or equal to the value of right operand.
  | LessEqual
  -- True when left operand is greater than the value of right operand.
  | Greater
  -- True when left operand is greater than or equal to the value of right operand.
  | GreaterEqual
  -- True when x and y are the same object.
  | Is
  -- Negation of `x is y`.
  | IsNot
  -- True when x is a member of s.
  | In
  -- Negation of `x in s`
  | NotIn


{- Based on RustPython. -}
{- CPython uses 'JoinedStr(expr* values)', but we know that values are strings. -}

{-
@enum StringGroup =
  String(String)
  CPython: FormattedValue(expr value, int? conversion, expr? format_spec)
  | FormattedValue(expr value, ConversionFlag? conversion, String spec)
  | JoinedString(StringGroup*) -- JoinedStr(expr* values)
 -}

-- Transforms a value prior to formatting it.
@enum ConversionFlag =
  -- Converts by calling `str(<value>)`.
  Str
  -- Converts by calling `ascii(<value>)`.
  | Ascii
  -- Converts by calling `repr(<value>)`.
  | Repr

@struct Slice = (
  sliceKind kind,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

@enum SliceKind =
  -- Regular slicing: `movies[pinocchio:frozen2]`.
  Slice(expr? lower, expr? upper, expr? step)
  -- Advanced slicing: `frozen[kristoff:ana, olaf]`.
  -- `dims` holds a list of `Slice` and `Index` nodes.
 | ExtSlice(slice* dims)
  -- Subscripting with a single value: `frozen[elsa]`.
 | Index(expr)

-- One `for` clause in a comprehension.
@struct Comprehension = (
  -- Reference to use for each element,
  -- typically a `Identifier` or `Tuple` node.
  expr target,
  -- Object to iterate over.
  expr iter,
  -- List of test expressions. We can have multiple `ifs`.
  expr* ifs,
  -- Indicates that the comprehension is asynchronous.
  Bool isAsync,

  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

{-
-- excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
--                 attributes (int lineno, int col_offset)
-}

-- The arguments for a function passed by value
-- (where the value is always an object reference, not the value of the object).
-- https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions"
@struct arguments = (
  -- Function positional arguments.
  -- When a function is called, positional arguments are mapped
  -- to these parameters based solely on their position.
  arg* args,
  -- Default values for positional arguments.
  -- If there are fewer defaults, they correspond to the last *n* arguments.
  -- - Important: The default value is evaluated only **once**.
  expr* defaults,

  -- Non-keyworded variable length arguments.
  -- By convention called `*args`.
  vararg vararg,
  -- Parameters which occur after the '*args'.
  -- Can only be used as keywords rather than positional arguments.
  -- CPython `kwonlyargs`.
  arg* kwOnlyArgs,
  -- Default values for keyword-only arguments.
  -- If no default value is specified then implicit `None` is assumed.
  -- CPython `kw_defaults`.
  -- - Important: The default value is evaluated only **once**.
  expr* kwOnlyDefaults,

  -- Keyworded (named) variable length arguments.
  -- By convention called `**kwargs`.
  arg? kwarg,

  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

@struct arg = (
  -- Argument name.
  identifier name,
  -- Python expression evaluated at compile time.
  -- Not used during runtime, can be used by third party libraries.
  -- Introduced in PEP 3107.
  expr? annotation,
  -- Location of the first character in the source code.
  loc start,
  -- Location just after the last character in the source code.
  loc end
)

@enum vararg =
  none
  -- Separator for keyword arguments. Represented by just `*`.
  | unnamed
  | named(Arg)

-- Keyword arguments supplied to call (`nil` identifier for `**kwargs`).
{- @struct keyword = (
  identifier? name,
  expr value
) -}

{-
-- -- import name with optional 'as' alias.
-- alias = (identifier name, identifier? asname)
--
-- withitem = (expr context_expr, expr? optional_vars)
-}
