import Core
import Lexer
import Parser
import Compiler
import Foundation

// In CPython:
// Python -> _warnings.c
// https://docs.python.org/3/library/warnings.html

// MARK: - PyWarningEnum

/// Warning typesm but as an enum.
///
/// Helper for `Py.warn` method.
public enum PyWarningEnum {

  /// Base class for warning categories.
  case warning
  /// Base class for warnings about deprecated features.
  case deprecation
  /// Base class for warnings about features which will be deprecated
  /// in the future.
  case pendingDeprecation
  /// Base class for warnings about dubious runtime behavior.
  case runtime
  /// Base class for warnings about dubious syntax.
  case syntax
  /// Base class for warnings generated by user code.
  case user
  /// Base class for warnings about constructs that will change semantically
  /// in the future.
  case future
  /// Base class for warnings about probable mistakes in module imports
  case `import`
  /// Base class for warnings about Unicode related problems, mostly
  /// related to conversion problems.
  case unicode
  /// Base class for warnings about bytes and buffer related problems,
  /// mostly related to conversion from str or comparing to str.
  case bytes
  /// Base class for warnings about resource usage.
  case resource

  internal var asPyType: PyType {
    switch self {
    case .warning: return Py.errorTypes.warning
    case .deprecation: return Py.errorTypes.deprecationWarning
    case .pendingDeprecation: return Py.errorTypes.pendingDeprecationWarning
    case .runtime: return Py.errorTypes.runtimeWarning
    case .syntax: return Py.errorTypes.syntaxWarning
    case .user: return Py.errorTypes.userWarning
    case .future: return Py.errorTypes.futureWarning
    case .import: return Py.errorTypes.importWarning
    case .unicode: return Py.errorTypes.unicodeWarning
    case .bytes: return Py.errorTypes.bytesWarning
    case .resource: return Py.errorTypes.resourceWarning
    }
  }
}

// MARK: - BuiltinFunctions

extension BuiltinFunctions {

  // MARK: - Common usage

  public func warn(warning: LexerWarning) -> PyBaseException? {
    let msg = String(describing: warning)
    return self.warn(type: .syntax, msg: msg)
  }

  public func warn(warning: ParserWarning) -> PyBaseException? {
    let msg = String(describing: warning)
    return self.warn(type: .syntax, msg: msg)
  }

  public func warn(warning: CompilerWarning) -> PyBaseException? {
    let msg = String(describing: warning)
    return self.warn(type: .syntax, msg: msg)
  }

  public func warnBytesIfEnabled(msg: String) -> PyBaseException? {
    // We will call 'getInterned' because messages tend to be repeated.
    switch Py.sys.flags.bytesWarning {
    case .ignore:
      return nil

    case .warning:
      let msgObject = Py.getInterned(msg)
      return self.warn(type: .bytes, msg: msgObject)

    case .error:
      let msgObject = Py.getInterned(msg)
      let args = Py.newTuple(msgObject)
      let error = PyBytesWarning(args: args)
      return error
    }
  }

  // MARK: - Warn

  public func warn(type: PyWarningEnum, msg: String) -> PyBaseException? {
    return self.warn(type: type.asPyType, msg: msg)
  }

  public func warn(type: PyWarningEnum, msg: PyString) -> PyBaseException? {
    return self.warn(type: type.asPyType, msg: msg)
  }

  public func warn(type: PyType, msg: String) -> PyBaseException? {
    let object = Py.newString(msg)
    return self.warn(type: type, msg: object)
  }

  public func warn(type: PyType, msg: PyString) -> PyBaseException? {
    assert(type.isSubtype(of: Py.errorTypes.warning))
    switch Py._warnings.warn(message: msg, category: type) {
    case .value:
      return nil
    case .error(let e):
      return e
    }
  }
}
