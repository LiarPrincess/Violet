import Core
import Lexer
import Parser
import Compiler
import Foundation

// In CPython:
// Python -> _warnings.c
// https://docs.python.org/3/library/warnings.html

// MARK: - PyWarningEnum

/// Helper for `Py.warn` method.
public enum PyWarningEnum {

  /// Base class for warning categories.
  case warning
  /// Base class for warnings about deprecated features.
  case deprecation
  /// Base class for warnings about features which will be deprecated
  /// in the future.
  case pendingDeprecation
  /// Base class for warnings about dubious runtime behavior.
  case runtime
  /// Base class for warnings about dubious syntax.
  case syntax
  /// Base class for warnings generated by user code.
  case user
  /// Base class for warnings about constructs that will change semantically
  /// in the future.
  case future
  /// Base class for warnings about probable mistakes in module imports
  case `import`
  /// Base class for warnings about Unicode related problems, mostly
  /// related to conversion problems.
  case unicode
  /// Base class for warnings about bytes and buffer related problems,
  /// mostly related to conversion from str or comparing to str.
  case bytes
  /// Base class for warnings about resource usage.
  case resource

  fileprivate var py: PyType {
    switch self {
    case .warning: return Py.errorTypes.warning
    case .deprecation: return Py.errorTypes.deprecationWarning
    case .pendingDeprecation: return Py.errorTypes.pendingDeprecationWarning
    case .runtime: return Py.errorTypes.runtimeWarning
    case .syntax: return Py.errorTypes.syntaxWarning
    case .user: return Py.errorTypes.userWarning
    case .future: return Py.errorTypes.futureWarning
    case .import: return Py.errorTypes.importWarning
    case .unicode: return Py.errorTypes.unicodeWarning
    case .bytes: return Py.errorTypes.bytesWarning
    case .resource: return Py.errorTypes.resourceWarning
    }
  }
}

// MARK: - BuiltinFunctions

extension BuiltinFunctions {

  public func warn(type: PyWarningEnum, msg: String) -> PyBaseException? {
    return self.warn(type: type.py, msg: msg)
  }

  public func warn(type: PyType, msg: String) -> PyBaseException? {
    assert(type.isSubtype(of: Py.errorTypes.warning))

    let msgObject = Py.newString(msg)
    switch Py._warnings.warn(message: msgObject, category: type) {
    case .value:
      return nil
    case .error(let e):
      return e
    }
  }
}
