import Core
import Lexer
import Parser
import Compiler
import Foundation

// In CPython:
// Python -> _warnings.c
// https://docs.python.org/3/library/warnings.html

// MARK: - PyWarningEnum

/// Warning typesm but as an enum.
///
/// Helper for `Py.warn` method.
public enum PyWarningEnum {

  /// Base class for warning categories.
  case warning
  /// Base class for warnings about deprecated features.
  case deprecation
  /// Base class for warnings about features which will be deprecated
  /// in the future.
  case pendingDeprecation
  /// Base class for warnings about dubious runtime behavior.
  case runtime
  /// Base class for warnings about dubious syntax.
  case syntax
  /// Base class for warnings generated by user code.
  case user
  /// Base class for warnings about constructs that will change semantically
  /// in the future.
  case future
  /// Base class for warnings about probable mistakes in module imports
  case `import`
  /// Base class for warnings about Unicode related problems, mostly
  /// related to conversion problems.
  case unicode
  /// Base class for warnings about bytes and buffer related problems,
  /// mostly related to conversion from str or comparing to str.
  case bytes
  /// Base class for warnings about resource usage.
  case resource

  internal var asPyType: PyType {
    switch self {
    case .warning: return Py.errorTypes.warning
    case .deprecation: return Py.errorTypes.deprecationWarning
    case .pendingDeprecation: return Py.errorTypes.pendingDeprecationWarning
    case .runtime: return Py.errorTypes.runtimeWarning
    case .syntax: return Py.errorTypes.syntaxWarning
    case .user: return Py.errorTypes.userWarning
    case .future: return Py.errorTypes.futureWarning
    case .import: return Py.errorTypes.importWarning
    case .unicode: return Py.errorTypes.unicodeWarning
    case .bytes: return Py.errorTypes.bytesWarning
    case .resource: return Py.errorTypes.resourceWarning
    }
  }
}

// MARK: - BuiltinFunctions

extension BuiltinFunctions {

  // MARK: - Syntax

  public func warn(filename: String,
                   warning: LexerWarning) -> PyBaseException? {
    return self.warnSyntax(
      filename: filename,
      line: warning.location.line,
      column: warning.location.column,
      text: String(describing: warning)
    )
  }

  public func warn(filename: String,
                   warning: ParserWarning) -> PyBaseException? {
    return self.warnSyntax(
      filename: filename,
      line: warning.location.line,
      column: warning.location.column,
      text: String(describing: warning)
    )
  }

  public func warn(filename: String,
                   warning: CompilerWarning) -> PyBaseException? {
    return self.warnSyntax(
      filename: filename,
      line: warning.location.line,
      column: warning.location.column,
      text: String(describing: warning)
    )
  }

  public func warnSyntax(filename: String,
                         line: SourceLine,
                         column: SourceColumn,
                         text: String) -> PyBaseException? {
    return self.warnSyntax(
      filename: Py.intern(filename),
      line: Py.newInt(Int(line)),
      column: Py.newInt(Int(column)),
      text: Py.newString(text)
    )
  }

  public func warnSyntax(filename: PyString,
                         line: PyInt,
                         column: PyInt,
                         text: PyString) -> PyBaseException? {
    let e = self.newSyntaxWarning(
      filename: filename,
      line: line,
      column: column,
      text: text
    )

    switch Py._warnings.warn(message: e) {
    case .value:
      return nil
    case .error(let e):
      return e
    }
  }

  public func newSyntaxWarning(filename: String,
                               line: SourceLine,
                               column: SourceColumn,
                               text: String) -> PySyntaxWarning {
    return self.newSyntaxWarning(
      filename: Py.intern(filename),
      line: Py.newInt(Int(line)),
      column: Py.newInt(Int(column)),
      text: Py.newString(text)
    )
  }

  public func newSyntaxWarning(filename: PyString,
                               line: PyInt,
                               column: PyInt,
                               text: PyString) -> PySyntaxWarning {
    let args = Py.newTuple(text)
    let e = PySyntaxWarning(args: args)
    self.fillSyntaxErrorDict(error: e,
                             filename: filename,
                             line: line,
                             column: column,
                             text: text)
    return e
  }

  // MARK: - Bytes

  public func warnBytesIfEnabled(msg: String) -> PyBaseException? {
    // We will call 'getInterned' because messages tend to be repeated.
    switch Py.sys.flags.bytesWarning {
    case .ignore:
      return nil

    case .warning:
      let msgObject = Py.intern(msg)
      return self.warn(type: .bytes, msg: msgObject)

    case .error:
      let msgObject = Py.intern(msg)
      let args = Py.newTuple(msgObject)
      let error = PyBytesWarning(args: args)
      return error
    }
  }

  // MARK: - Warn

  public func warn(type: PyWarningEnum, msg: String) -> PyBaseException? {
    return self.warn(type: type.asPyType, msg: msg)
  }

  public func warn(type: PyWarningEnum, msg: PyString) -> PyBaseException? {
    return self.warn(type: type.asPyType, msg: msg)
  }

  public func warn(type: PyType, msg: String) -> PyBaseException? {
    let object = Py.newString(msg)
    return self.warn(type: type, msg: object)
  }

  public func warn(type: PyType, msg: PyString) -> PyBaseException? {
    assert(type.isSubtype(of: Py.errorTypes.warning))
    switch Py._warnings.warn(message: msg, category: type) {
    case .value:
      return nil
    case .error(let e):
      return e
    }
  }
}
