import Foundation
import BigInt
import VioletCore
import VioletLexer
import VioletParser
import VioletCompiler

// In CPython:
// Python -> _warnings.c
// https://docs.python.org/3/library/warnings.html

// MARK: - PyWarningEnum

/// Warning types, but as an `enum`.
///
/// Helper for `Py.warn` method.
public enum PyWarningEnum {

  /// Base class for warning categories.
  case warning
  /// Base class for warnings about deprecated features.
  case deprecation
  /// Base class for warnings about features which will be deprecated
  /// in the future.
  case pendingDeprecation
  /// Base class for warnings about dubious runtime behavior.
  case runtime
  /// Base class for warnings about dubious syntax.
  case syntax
  /// Base class for warnings generated by user code.
  case user
  /// Base class for warnings about constructs that will change semantically
  /// in the future.
  case future
  /// Base class for warnings about probable mistakes in module imports
  case `import`
  /// Base class for warnings about Unicode related problems, mostly
  /// related to conversion problems.
  case unicode
  /// Base class for warnings about bytes and buffer related problems,
  /// mostly related to conversion from str or comparing to str.
  case bytes
  /// Base class for warnings about resource usage.
  case resource

  internal var asPyType: PyType {
    switch self {
    case .warning: return Py.errorTypes.warning
    case .deprecation: return Py.errorTypes.deprecationWarning
    case .pendingDeprecation: return Py.errorTypes.pendingDeprecationWarning
    case .runtime: return Py.errorTypes.runtimeWarning
    case .syntax: return Py.errorTypes.syntaxWarning
    case .user: return Py.errorTypes.userWarning
    case .future: return Py.errorTypes.futureWarning
    case .import: return Py.errorTypes.importWarning
    case .unicode: return Py.errorTypes.unicodeWarning
    case .bytes: return Py.errorTypes.bytesWarning
    case .resource: return Py.errorTypes.resourceWarning
    }
  }
}

extension PyInstance {

  // MARK: - Syntax

  public func warn(filename: String,
                   warning: LexerWarning) -> PyBaseException? {
    return self.warnSyntax(
      filename: filename,
      line: warning.location.line,
      column: warning.location.column,
      text: String(describing: warning)
    )
  }

  public func warn(filename: String,
                   warning: ParserWarning) -> PyBaseException? {
    return self.warnSyntax(
      filename: filename,
      line: warning.location.line,
      column: warning.location.column,
      text: String(describing: warning)
    )
  }

  public func warn(filename: String,
                   warning: CompilerWarning) -> PyBaseException? {
    return self.warnSyntax(
      filename: filename,
      line: warning.location.line,
      column: warning.location.column,
      text: String(describing: warning)
    )
  }

  public func warnSyntax(filename: String,
                         line: SourceLine,
                         column: SourceColumn,
                         text: String) -> PyBaseException? {
    return self.warnSyntax(
      filename: self.intern(string: filename),
      line: self.newInt(Int(line)),
      column: self.newInt(Int(column)),
      text: self.newString(text)
    )
  }

  public func warnSyntax(filename: PyString,
                         line: PyInt,
                         column: PyInt,
                         text: PyString) -> PyBaseException? {
    let message = self.newSyntaxWarning(
      filename: filename,
      line: line,
      column: column,
      text: text
    )

    let frame = self.delegate.frame
    let registry: UnderscoreWarnings.WarningRegistry
    switch self._warnings.getWarningRegistry(frame: frame) {
    case let .value(r): registry = r
    case let .error(e): return e
    }

    // We cannot use generic 'warn' as this time we have to point to specific
    // file/line.
    let result = self._warnings.warnExplicit(
      message: message,
      category: self.errorTypes.syntaxWarning,
      filename: filename,
      lineNo: line,
      module: nil,
      source: nil,
      registry: registry
    )

    switch result {
    case .value:
      return nil
    case .error(let e):
      return e
    }
  }

  public func newSyntaxWarning(filename: String,
                               line: BigInt,
                               column: BigInt,
                               text: String) -> PySyntaxWarning {
    let msg = "\(text) (\(filename), line \(line), offset: \(column))"
    return PySyntaxWarning(msg: msg)
  }

  public func newSyntaxWarning(filename: PyString,
                               line: PyInt,
                               column: PyInt,
                               text: PyString) -> PySyntaxWarning {
    return self.newSyntaxWarning(
      filename: filename.value,
      line: line.value,
      column: column.value,
      text: text.value
    )
  }

  // MARK: - Bytes

  public func warnBytesIfEnabled(msg: String) -> PyBaseException? {
    // We will call 'getInterned' because messages tend to be repeated.
    switch self.sys.flags.bytesWarning {
    case .ignore:
      return nil

    case .warning:
      let msgObject = self.intern(string: msg)
      return self.warn(type: .bytes, msg: msgObject)

    case .error:
      let msgObject = self.intern(string: msg)
      let args = self.newTuple(elements: msgObject)
      let error = PyBytesWarning(args: args)
      return error
    }
  }

  // MARK: - Warn

  public func warn(type: PyWarningEnum, msg: String) -> PyBaseException? {
    return self.warn(type: type.asPyType, msg: msg)
  }

  public func warn(type: PyWarningEnum, msg: PyString) -> PyBaseException? {
    return self.warn(type: type.asPyType, msg: msg)
  }

  public func warn(type: PyType, msg: String) -> PyBaseException? {
    let object = self.newString(msg)
    return self.warn(type: type, msg: object)
  }

  public func warn(type: PyType, msg: PyString) -> PyBaseException? {
    assert(type.isSubtype(of: self.errorTypes.warning))
    switch self._warnings.warn(message: msg, category: type) {
    case .value:
      return nil
    case .error(let e):
      return e
    }
  }
}
