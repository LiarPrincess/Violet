// swiftlint:disable:previous vertical_whitespace
// swiftlint:disable vertical_whitespace
// swiftlint:disable line_length
// swiftlint:disable file_length
// swiftlint:disable function_body_length

{% macro warnIfNotFinal type %}
    {# (Almost) All types have to be marked final #}
    {# Btw. stencil has problem with: 'not (type.isFinal or type.name == "PyInt")' #}
    {% if not type.isFinal and type.name != "PyInt" %}
    #warning("Type {{ type.name }} should be marked final.")
    {% endif %}
{% endmacro %}

{% macro fillDict type %}
  {% set castSelf %}selfAs{{ type.name }}{% endset %}

  {% for prop in type.instanceMethods|annotated:"pyproperty" %}
    {% set attribute %}{{ prop.annotations.pyproperty }}{% endset %}
    {% set getter %}{{ type.name }}.{{ prop.selectorName }}{% endset %}
    {% if prop.annotations.setter %}
    result._attributes["{{ attribute }}"] = PyType.createProperty(context, name: "{{ attribute }}", doc: nil, get: {{ getter }}, set: {{ type.name }}.{{ prop.annotations.setter }}, castSelf: PyType.{{ castSelf }})
    {% else %}
    result._attributes["{{ attribute }}"] = PyType.createProperty(context, name: "{{ attribute }}", doc: nil, get: {{ getter }}, castSelf: PyType.{{ castSelf }})
    {% endif %}
    {% endfor %}

    {% for method in type.staticMethods|annotated:"pymethod" %}
    {% set attribute %}{{ method.annotations.pymethod }}{% endset %}
    result._attributes["{{ attribute }}"] = PyType.wrapMethod(context, name: "{{ attribute }}", doc: nil, func: {{ type.name }}.{{ method.selectorName }})
    {% endfor %}

    {% for method in type.instanceMethods|annotated:"pymethod" %}
    {% set attribute %}{{ method.annotations.pymethod }}{% endset %}
    result._attributes["{{ attribute }}"] = PyType.wrapMethod(context, name: "{{ attribute }}", doc: nil, func: {{ type.name }}.{{ method.selectorName }}, castSelf: PyType.{{ castSelf }})
  {% endfor %}
{% endmacro %}

extension PyType {

  // MARK: - Base object
{% for type in types.enums where type.name == "PyBaseObject" %}

  /// Create `object` type without assigning `type` property.
  internal static func objectWithoutType(_ context: PyContext) -> PyType {
    let result = PyType.initWithoutType(context, name: "object", doc: PyBaseObject.doc, base: nil)
    {% call fillDict type %}
    return result
  }
{% endfor %}

  // MARK: - Type type
{% for type in types.classes where type.name == "PyType" %}

  /// Create `type` type without assigning `type` property.
  internal static func typeWithoutType(_ context: PyContext, base: PyType) -> PyType {
    {% call warnIfNotFinal type %}
    let result = PyType.initWithoutType(context, name: "type", doc: PyType.doc, base: base)
    {% call fillDict type %}
    return result
  }
{% endfor %}
{% for type in types.classes|annotated:"pytype" %}

  // MARK: - {{ type.name|replace:"Py","" }}

  {# To find 'doc' we iterate all static variables looking for 'doc', if that fails then assign 'nil' #}
  {% set doc %}{% for variable in type.staticVariables where variable.name == "doc" %}{{ type.name }}.doc{% endfor %}{% endset %}
  {% set docOrNil %}{% if doc == "" %}nil{% else %}{{ doc }}{% endif %}{% endset %}
  {% set fnName %}{{ type.annotations.pytype|replace:"Type",""|replace:"types",""|replace:".",""|lowerFirstWord }}{% endset %}
  internal static func {{ fnName }}(_ context: PyContext, type: PyType, base: PyType) -> PyType {
    {% call warnIfNotFinal type %}
    let result = PyType(context, name: "{{ type.annotations.pytype }}", doc: {{ docOrNil }}, type: type, base: base)
    {% call fillDict type %}
    return result
  }
{% endfor %}
{% for type in types.classes|annotated:"pyerrortype" %}

  // MARK: - {{ type.name|replace:"Py","" }}

  {# To find 'doc' we iterate all static variables looking for 'doc', if that fails then assign 'nil' #}
  {% set doc %}{% for variable in type.staticVariables where variable.name == "doc" %}{{ type.name }}.doc{% endfor %}{% endset %}
  {% set docOrNil %}{% if doc == "" %}nil{% else %}{{ doc }}{% endif %}{% endset %}
  {% set fnName %}{{ type.annotations.pyerrortype|replace:"Type",""|replace:"types",""|replace:".",""|lowerFirstWord }}{% endset %}
  internal static func {{ fnName }}(_ context: PyContext, type: PyType, base: PyType) -> PyType {
    {% call warnIfNotFinal type %}
    let result = PyType(context, name: "{{ type.annotations.pyerrortype }}", doc: {{ docOrNil }}, type: type, base: base)
    {% call fillDict type %}
    return result
  }
{% endfor %}
}
{% for type in types.classes|annotated:"pywarningtype" %}

  // MARK: - {{ type.name|replace:"Py","" }}

  {# To find 'doc' we iterate all static variables looking for 'doc', if that fails then assign 'nil' #}
  {% set doc %}{% for variable in type.staticVariables where variable.name == "doc" %}{{ type.name }}.doc{% endfor %}{% endset %}
  {% set docOrNil %}{% if doc == "" %}nil{% else %}{{ doc }}{% endif %}{% endset %}
  {% set fnName %}{{ type.annotations.pywarningtype|replace:"Type",""|replace:"types",""|replace:".",""|lowerFirstWord }}{% endset %}
  internal static func {{ fnName }}(_ context: PyContext, type: PyType, base: PyType) -> PyType {
    {% call warnIfNotFinal type %}
    let result = PyType(context, name: "{{ type.annotations.pywarningtype }}", doc: {{ docOrNil }}, type: type, base: base)
    {% call fillDict type %}
    return result
  }
{% endfor %}
}
