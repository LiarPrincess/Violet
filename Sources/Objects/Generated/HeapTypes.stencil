// swiftlint:disable vertical_whitespace
// swiftlint:disable file_length

// Types used when we subclass one of the builtin types.
//
// Normally most builtin types (like int, float etc.) do not have '__dict__'.
// But if we subclass then then '__dict__' is now present.
//
// For example:
// >>> 1.__dict__ # Builtin int does not have '__dict__'
// SyntaxError: invalid syntax
//
// >>> class MyInt(int): pass
// >>> MyInt().__dict__ # But the subclass has
// { }

internal protocol HeapType: __dict__GetterOwner {
  var __dict__: PyDict { get set }
}

extension HeapType {
  internal func getDict() -> PyDict {
    return self.__dict__
  }
}

{% macro printHeapType swift_type python_type %}
/// Type used when we subclass builtin `{{ python_type }}` class.
/// For example: `class Rapunzel({{ python_type }}): pass`.
internal final class {{ swift_type }}Heap: {{ swift_type }}, HeapType {

  /// Python `__dict__` property.
  internal lazy var __dict__ = PyDict()
}
{% endmacro %}

{% macro tryHeapType type %}
  {# If we already have 'attributes: Attributes' then we dont need 'Heap' type #}
  {% set has__dict__ %}{% for variable in type.allVariables where variable.name == "__dict__" %}x{% endfor %}{% endset %}

// MARK: - {{ type.name|replace:"Py","" }}

  {% if not type.annotations.baseType %}
// {{ type.name }} is not a base type.
  {% else %}{% if has__dict__ %}
// {{ type.name }} already has everything we need.
  {% else %}
{% call printHeapType type.name type.annotations.pytype %}
  {% endif %}
  {% endif %}
{% endmacro %}

// MARK: - Object

{% for type in types.enums where type.name == "PyBaseObject" %}
{% call printHeapType "PyObject" "object" %}
{% endfor %}

// MARK: - Type type

// PyType already has everything we need.

{# Normal types #}
{% for type in types.classes|annotated:"pytype" %}
{% call tryHeapType type %}
{% endfor %}

{# Error types #}
{% for type in types.classes|annotated:"pyerrortype" %}
{% call tryHeapType type %}
{% endfor %}
