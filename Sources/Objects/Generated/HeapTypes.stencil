// swiftlint:disable vertical_whitespace
// swiftlint:disable file_length

// Types used when we subclass on of the builtin types.
//
// Normally most builtin types (like int, float etc.) do not have `__dict__`.
// But if we subclass then then `__dict__` is now present.
//
// For example:
// ```Python
// >>> 1.__dict__ # Builtin int does not have `__dict__`
// SyntaxError: invalid syntax
//
// >>> class MyInt(int): pass
// >>> MyInt().__dict__ # But the subclass has
// { }
// ```

internal protocol HeapType: __dict__GetterOwner {
  var __dict__: PyDict { get set }
}

extension HeapType {
  internal func getDict() -> PyDict {
    return self.__dict__
  }
}

{% macro printHeapType type_name %}
/// Type used when we subclass builtin `{{ type.annotations.pytype }}` class.
/// For example: `class Rapunzel({{ type.annotations.pytype }}): pass`.
internal final class {{ type_name }}Heap: {{ type_name }}, HeapType {

  /// Python `__dict__` property.
  internal lazy var __dict__ = PyDict()
}
{% endmacro %}

{% macro tryHeapType type %}
  {# If we already have 'attributes: Attributes' then we dont need 'Heap' type #}
  {% set has__dict__ %}{% for variable in type.allVariables where variable.name == "__dict__" %}x{% endfor %}{% endset %}

// MARK: - {{ type.name|replace:"Py","" }}

  {% if not type.annotations.baseType %}
// {{ type.name }} is not a base type.
  {% else %}{% if has__dict__ %}
// {{ type.name }} already has everything we need.
  {% else %}
{% call printHeapType type.name %}
  {% endif %}
  {% endif %}
{% endmacro %}

// MARK: - Object

{% for type in types.enums where type.name == "PyBaseObject" %}
{% call printHeapType "PyObject" %}
{% endfor %}

// MARK: - Type type

// PyType already has everything we need.

{# Normal types #}
{% for type in types.classes|annotated:"pytype" %}
{% call tryHeapType type %}
{% endfor %}

{# Error types #}
{% for type in types.classes|annotated:"pyerrortype" %}
{% call tryHeapType type %}
{% endfor %}
