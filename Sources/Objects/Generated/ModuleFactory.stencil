// swiftlint:disable vertical_whitespace
// swiftlint:disable line_length
// swiftlint:disable function_body_length

// ModuleFactory is based on pre-specialization (partial application)
// of function to module object and then wrapping remaining function.
//
// So, for example:
//   Builtins.add :: (self: Builtins) -> (left: PyObject, right: PyObject) -> Result
// would be specialized to 'Builtins' instance giving us:
//   add :: (left: PyObject, right: PyObject) -> Result
// which would be wrapped and exposed to Python runtime.
//
// So when you are working on Python 'builtins' you are actually working on
// (Scooby-Doo reveal incomming...)
// 'Py.builtins' object (which gives us stateful modules).
// (and we would have gotten away with it without you meddling kids!)
// https://www.youtube.com/watch?v=b4JLLv1lE7A

import Core

private func insert(module: PyModule, name: String, value: PyObject) {
  let dict = module.getDict()
  let interned = Py.getInterned(name)

  switch dict.set(key: interned, to: value) {
  case .ok:
    break
  case .error(let e):
    trap("Error when inserting '\(name)' to '\(module)' module: \(e)")
  }
}

internal enum ModuleFactory {
{% for type in types.classes|annotated:"pymodule" %}

  // MARK: - {{ type.name }}

  internal static func create{{ type.name }}(from object: {{ type.name }}) -> PyModule {
    let module = PyModule(name: "{{ type.annotations.pymodule }}", doc: nil)

  {% for prop in type.allVariables|annotated:"pyproperty" %}
    {% set attribute %}{{ prop.annotations.pyproperty }}{% endset %}
    insert(module: module, name: "{{ attribute }}", value: object.{{ prop.name }})
  {% endfor %}

  {% for prop in type.allMethods|annotated:"pyproperty" %}
    {% set attribute %}{{ prop.annotations.pyproperty }}{% endset %}
    {% set getter %}object.{{ prop.selectorName }}{% endset %}
    {% if prop.annotations.setter %}
    insert(module: module, name: "{{ attribute }}", value: PyProperty.wrap(name: "{{ attribute }}", doc: nil, get: {{ getter }}, set: object.{{ prop.annotations.setter }}))
    {% else %}
    insert(module: module, name: "{{ attribute }}", value: PyProperty.wrap(name: "{{ attribute }}", doc: nil, get: {{ getter }}))
    {% endif %}
  {% endfor %}

  {% for method in type.allMethods|annotated:"pymethod" %}
    {% set attribute %}{{ method.annotations.pymethod }}{% endset %}
    insert(module: module, name: "{{ attribute }}", value: PyBuiltinFunction.wrap(name: "{{ attribute }}", doc: nil, fn: object.{{ method.selectorName }}, module: module))
  {% endfor %}

    return module
  }
{% endfor %}
}
