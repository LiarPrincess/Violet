// swiftlint:disable vertical_whitespace
// swiftlint:disable vertical_whitespace_closing_braces
// swiftlint:disable line_length
// swiftlint:disable file_length
// swiftlint:disable function_body_length

// Please note that this file was automatically generated. DO NOT EDIT!
// The same goes for other files in 'Generated' directory.

/// Add all of boring stuff to 'PyType'.
///
/// For example it will:
/// - set type flags
/// - add `__doc__`
/// - fill `__dict__`

import Core

private func insert(type: PyType, name: String, value: PyObject) {
  let dict = type.getDict()
  let interned = Py.getInterned(name)

  switch dict.set(key: interned, to: value) {
  case .ok:
    break
  case .error(let e):
    trap("Error when inserting '\(name)' to '\(type.getName())' type: \(e)")
  }
}

{% macro addDoc type %}
    {# To find 'doc' we iterate all static variables looking for 'doc', if that fails then assign 'nil' #}
    {% set doc %}{% for variable in type.staticVariables where variable.name == "doc" %}{{ type.name }}.doc{% endfor %}{% endset %}
    {% set docOrNil %}{% if doc == "" %}nil{% else %}{{ doc }}{% endif %}{% endset %}
    type.setBuiltinTypeDoc({{ docOrNil }})
{% endmacro %}

{% macro addFlags type %}
    {% if type.annotations.default %}type.setFlag(.default){% endif %}
    {% if type.annotations.heapType %}type.setFlag(.heapType){% endif %}
    {% if type.annotations.baseType %}type.setFlag(.baseType){% endif %}
    {% if type.annotations.hasGC %}type.setFlag(.hasGC){% endif %}
    {% if type.annotations.isAbstract %}type.setFlag(.isAbstract){% endif %}
    {% if type.annotations.hasFinalize %}type.setFlag(.hasFinalize){% endif %}
    {% if type.annotations.longSubclass %}type.setFlag(.longSubclass){% endif %}
    {% if type.annotations.listSubclass %}type.setFlag(.listSubclass){% endif %}
    {% if type.annotations.tupleSubclass %}type.setFlag(.tupleSubclass){% endif %}
    {% if type.annotations.bytesSubclass %}type.setFlag(.bytesSubclass){% endif %}
    {% if type.annotations.unicodeSubclass %}type.setFlag(.unicodeSubclass){% endif %}
    {% if type.annotations.dictSubclass %}type.setFlag(.dictSubclass){% endif %}
    {% if type.annotations.baseExceptionSubclass %}type.setFlag(.baseExceptionSubclass){% endif %}
    {% if type.annotations.typeSubclass %}type.setFlag(.typeSubclass){% endif %}
{% endmacro %}

{% macro addLayout name %}
    type.setLayout(.{{ name }})
{% endmacro %}

{% macro fillDict type pyName %}
  {% set castSelf %}Cast.as{{ type.name }}{% endset %}

  {% for prop in type.instanceMethods|annotated:"pyproperty" %}
    {% set attribute %}{{ prop.annotations.pyproperty }}{% endset %}
    {% set getter %}{{ type.name }}.{{ prop.selectorName }}{% endset %}
    {% if prop.annotations.setter %}
    insert(type: type, name: "{{ attribute }}", value: PyProperty.wrap(name: "{{ attribute }}", doc: nil, get: {{ getter }}, set: {{ type.name }}.{{ prop.annotations.setter }}, castSelf: {{ castSelf }}))
    {% else %}
    insert(type: type, name: "{{ attribute }}", value: PyProperty.wrap(name: "{{ attribute }}", doc: nil, get: {{ getter }}, castSelf: {{ castSelf }}))
    {% endif %}
  {% endfor %}

  {% for method in type.staticMethods|annotated:"pymethod" %}
    {% set attribute %}{{ method.annotations.pymethod }}{% endset %}
    {% if attribute == "__new__" %}
    insert(type: type, name: "{{ attribute }}", value: PyBuiltinFunction.wrapNew(type: type, doc: nil, fn: {{ type.name }}.{{ method.selectorName }}))
    {% else %}
    {% if attribute == "__init__" %}
    insert(type: type, name: "{{ attribute }}", value: PyBuiltinFunction.wrapInit(type: type, doc: nil, fn: {{ type.name }}.{{ method.selectorName }}))
    {% else %}
    insert(type: type, name: "{{ attribute }}", value: PyBuiltinFunction.wrap(name: "{{ attribute }}", doc: nil, fn: {{ type.name }}.{{ method.selectorName }}))
    {% endif %}
    {% endif %}
  {% endfor %}

  {% for method in type.classMethods|annotated:"pymethod" %}
    {% set attribute %}{{ method.annotations.pymethod }}{% endset %}
    {% if attribute == "__new__" %}
    insert(type: type, name: "{{ attribute }}", value: PyBuiltinFunction.wrapNew(type: type, doc: nil, fn: {{ type.name }}.{{ method.selectorName }}))
    {% else %}
    {% if attribute == "__init__" %}
    insert(type: type, name: "{{ attribute }}", value: PyBuiltinFunction.wrapInit(type: type, doc: nil, fn: {{ type.name }}.{{ method.selectorName }}))
    {% else %}
    insert(type: type, name: "{{ attribute }}", value: PyBuiltinFunction.wrap(name: "{{ attribute }}", doc: nil, fn: {{ type.name }}.{{ method.selectorName }}))
    {% endif %}
    {% endif %}
  {% endfor %}

  {% for method in type.instanceMethods|annotated:"pymethod" %}
    {% set attribute %}{{ method.annotations.pymethod }}{% endset %}
    insert(type: type, name: "{{ attribute }}", value: PyBuiltinFunction.wrap(name: "{{ attribute }}", doc: nil, fn: {{ type.name }}.{{ method.selectorName }}, castSelf: {{ castSelf }}))
  {% endfor %}
{% endmacro %}

internal enum FillTypes {

{% for type in types.enums where type.name == "PyObjectType" %}

  // MARK: - Base object

  internal static func object(_ type: PyType) {
    {% call addDoc type %}
    {% call addFlags type %}
    {% call addLayout "PyObject" %}
    {% call fillDict type "object" %}
  }
{% endfor %}

{% for type in types.classes where type.name == "PyType" %}

  // MARK: - Type type

  internal static func type(_ type: PyType) {
    {% call addDoc type %}
    {% call addFlags type %}
    {% call addLayout type.name %}
    {% call fillDict type "type" %}
  }
{% endfor %}

{% for type in types.classes|annotated:"pytype" %}

  // MARK: - {{ type.name|replace:"Py","" }}

  {% set annotation %}{{ type.annotations.pytype|replace:"Type",""|replace:"types",""|replace:".","" }}{% endset %}
  {% set fnName %}{% if type.name == "PySuper" %}`super`{% else %}{{ annotation|lowerFirstWord }}{% endif %}{% endset %}
  internal static func {{ fnName }}(_ type: PyType) {
    {% call addDoc type %}
    {% call addFlags type %}
    {% call addLayout type.name %}
    {% call fillDict type annotation %}
  }
{% endfor %}
{% for type in types.classes|annotated:"pyerrortype" %}

  // MARK: - {{ type.name|replace:"Py","" }}

  {% set annotation %}{{ type.annotations.pyerrortype }}{% endset %}
  {% set fnName %}{{ annotation|lowerFirstWord }}{% endset %}
  internal static func {{ fnName }}(_ type: PyType) {
    {% call addDoc type %}
    {% call addFlags type %}
    {% call addLayout type.name %}
    {% call fillDict type annotation %}
  }
{% endfor %}
}
