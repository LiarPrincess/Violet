// swiftlint:disable:previous vertical_whitespace
// swiftlint:disable vertical_whitespace
// swiftlint:disable line_length
// swiftlint:disable file_length

types = {
{% for type in types.classes|annotated:"pytype" %}
  {% if type.annotations.pytype == "NoneType" %}
  type(None): [
  {% elif type.annotations.pytype == "NotImplementedType" %}
  type(NotImplemented): [
  {% elif type.annotations.pytype == "ellipsis" %}
  type(...): [
  {% else %}
  {{ type.annotations.pytype }}: [
  {% endif %}
  {% for method in type.allMethods|annotated:"pymethod" %}
    '{{ method.annotations.pymethod }}',
  {% endfor %}
  ],
{% endfor %}
}

extension PyType {
{% for type in types.classes|annotated:"pytype" %}

  internal static func {{ type.annotations.pytype }}(_ context: PyContext, type: PyType, base: PyType?) -> PyType {
    {# All types (except for PyInt) have to be marked final, stencil has problem with: 'not (type.isFinal or type.name == "PyInt")'#}
    {% if not type.isFinal and type.name != "PyInt" %}
    #warning("Type {{ type.name }} should be marked final.")
    {% endif %}
    let result = PyType(context, name: "{{ type.annotations.pytype }}", type: type, base: base)

    {% for variable in type.staticVariables where variable.name == "doc" %}
    // result.__doc__ = {{ type.name }}.{{ variable.name }}
    {% endfor %}

    {# Bool is subclass of Int, only Bool methods should be emitted, otherwise allMethods #}
    {% if type.annotations.pytype == "bool" %}
      {% for method in type.methods|annotated:"pymethod" %}
    // result.{{ method.annotations.pymethod }} = {{ type.name }}.{{ method.name }}
      {% endfor %}
    {% else %}
      {% for method in type.allMethods|annotated:"pymethod" %}
    // result.{{ method.annotations.pymethod }} = {{ type.name }}.{{ method.name }}
      {% endfor %}
    {% endif %}

    return result
  }
{% endfor %}
}
